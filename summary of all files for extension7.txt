===== FILE: ./logs.sh =====
#journalctl -f -o cat /usr/bin/gnome-shell
journalctl -f -o cat /usr/bin/gnome-shell | nl -ba




===== FILE: ./stylesheet.css =====
/* stylesheet.css */
/* Radii and colors for active/grouped are driven inline from JS to beat theme rules. */

.zone-highlight {
    background-color: rgba(100, 100, 255, 0.5);
    border: 2px solid rgba(200, 200, 255, 0.8);
    border-radius: 8px;
    transition-duration: 150ms;
}

.zone-tab-bar {
    padding: 0 4px;
}

.zone-tab {
    background-color: rgba(60, 60, 60, 0.9);
    border: 1px solid #222;
    border-bottom-width: 0;
    padding: 2px 8px;
    margin: 0 2px;
    transition-duration: 150ms;
    overflow: hidden; /* ensures child visuals don’t override radius */
}

.zone-tab:hover {
    background-color: rgba(80, 80, 80, 0.9);
}

.zone-tab:active,
.zone-tab:focus,
.zone-tab.active {
    /* The final background-color is set inline for the active tab from settings.
       We still tweak text/border contrast here. */
    color: white;
    border-color: #555;
}

.zone-tab-content {
    spacing: 6px;
}

.zone-tab-app-icon { }
.zone-tab-label { }

.zone-tab-close-button {
    background-color: transparent;
    border: none;
    padding: 2px;
    border-radius: 99px;
}

.zone-tab-close-button:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

/* --- Grouping Styles --- */
/* Thickness and glow stay in CSS; color itself comes from inline JS (settings). */
.zone-tab.grouped-start,
.zone-tab.grouped-middle,
.zone-tab.grouped-end {
    border-top-width: 3px;
    box-shadow: 0 0 4px rgba(74, 144, 226, 0.45);
}

.zone-tab.grouped-start {
    border-left-width: 3px;
    border-right-width: 0;
    margin-right: 0;
}

.zone-tab.grouped-middle {
    border-left-width: 0;
    border-right-width: 0;
    margin-left: 0;
    margin-right: 0;
}

.zone-tab.grouped-end {
    border-right-width: 3px;
    border-left-width: 0;
    margin-left: 0;
}

/* Slightly stronger glow when active (color stays consistent with inline border-color) */
.zone-tab.active.grouped-start,
.zone-tab.active.grouped-middle,
.zone-tab.active.grouped-end {
    box-shadow: 0 0 6px rgba(74, 144, 226, 0.60);
}




===== FILE: ./extension.js =====
// extension.js
import { Extension } from 'resource:///org/gnome/shell/extensions/extension.js';
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

import { WindowManager } from './modules/WindowManager.js';
import { ConfigManager } from './modules/ConfigManager.js';
import { Highlighter } from './modules/Highlighter.js';

const log = msg => console.log(`[TabbedTiling] ${msg}`);

export default class TabbedTilingExtension extends Extension {
    constructor(metadata) {
        super(metadata);
        this._configManager = null;
        this._windowManager = null;
        this._highlighter = null;
        this._configFileMonitor = null;
        this._previewFileMonitor = null;
    }

    enable() {
        // Don’t render tabs/overlays on lock screen or other non-user modes.
        // This prevents tab bars showing above the lock UI.
        if (Main.sessionMode.currentMode !== 'user') {
            return;
        }    
        log('Enabling...');

        this._configManager = new ConfigManager();
        this._highlighter = new Highlighter();
        this._windowManager = new WindowManager(this._configManager, this._highlighter);

        try {
            this._windowManager.enable();
            this._monitorConfigFiles();
            log('Enabled successfully.');
        } catch (e) {
            log(`Error during enable: ${e}`);
            this.disable();
        }
    }

    disable() {
        log('Disabling...');

        if (this._configFileMonitor) {
            this._configFileMonitor.cancel();
            this._configFileMonitor = null;
        }
        if (this._previewFileMonitor) {
            this._previewFileMonitor.cancel();
            this._previewFileMonitor = null;
        }

        if (this._windowManager) {
            this._windowManager.disable();
            this._windowManager = null;
        }

        if (this._highlighter) {
            this._highlighter.destroy();
            this._highlighter = null;
        }

        this._configManager = null;
        log('Disabled.');
    }

    _monitorConfigFiles() {
        // Monitor the main config file for changes from the preferences window
        const configFile = this._configManager.getConfigFile();
        this._configFileMonitor = configFile.monitor(Gio.FileMonitorFlags.NONE, null);
        this._configFileMonitor.connect('changed', (monitor, file, otherFile, eventType) => {
            if (eventType === Gio.FileMonitorEvent.CHANGES_DONE_HINT) {
                log('Config file changed, reloading zones...');
                GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {
                    this._windowManager.reloadConfiguration();
                    return GLib.SOURCE_REMOVE;
                });
            }
        });

        // Monitor the preview file for requests from the preferences window
        const previewFile = this._configManager.getPreviewFile();
        this._previewFileMonitor = previewFile.monitor(Gio.FileMonitorFlags.NONE, null);
        this._previewFileMonitor.connect('changed', (monitor, file, otherFile, eventType) => {
            if (eventType === Gio.FileMonitorEvent.CHANGES_DONE_HINT) {
                log('Preview file changed, showing preview...');
                const zones = this._configManager.loadPreviewZones();
                if (zones) {
                    this._highlighter.showAllPreviews(zones);
                }
            }
        });
    }
}



===== FILE: ./prefs.js =====
// prefs.js — TabbedTiling preferences (GNOME 48 / GJS)
// Works on X11; uses Adw, Gtk, GObject. Stores config in ~/.config/tabbedtiling/config.json

import Gio from 'gi://Gio';
import Gtk from 'gi://Gtk';
import Adw from 'gi://Adw';
import GLib from 'gi://GLib';
import GObject from 'gi://GObject';

import { ExtensionPreferences, gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';

// If you have a local ConfigManager module, you can keep using it.
// This file includes minimal file I/O, so ConfigManager is optional.
// import { ConfigManager } from './modules/ConfigManager.js';

const log = (msg) => console.log(`[TabbedTilingPrefs] ${msg}`);

const CONFIG_DIR = GLib.build_filenamev([GLib.get_home_dir(), '.config', 'tabbedtiling']);
const CONFIG_PATH = GLib.build_filenamev([CONFIG_DIR, 'config.json']);
const PREVIEW_PATH = GLib.build_filenamev([CONFIG_DIR, 'preview.json']);

function ensureConfigDir() {
    try {
        const f = Gio.File.new_for_path(CONFIG_DIR);
        if (!f.query_exists(null))
            f.make_directory_with_parents(null);
    } catch (e) {
        log(`Failed to ensure config dir: ${e}`);
    }
}

function defaultConfig() {
    return {
        zones: [],
        tabBar: {
            height: 32,
            backgroundColor: 'rgba(30,30,30,0.85)',
            // NEW defaults to match ConfigManager
            activeBgColor: 'rgba(0, 110, 200, 0.8)',
            groupBorderColor: '#4A90E2',            
            cornerRadius: 8,
            iconSize: 16,
            fontSize: 10, // in points (pt)
            spacing: 4, // between tabs
            maxWidth: 250, // max width of a single tab
            titleSource: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            groupingCriteria: 'appName', // 'appName', 'wmClass'
            closeButtonSize: 12,    
            sortingCriteria: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            sortingOrder: 'ASC', // 'ASC', 'DESC'                    
        },
    };
}

function loadConfig() {
    try {
        const file = Gio.File.new_for_path(CONFIG_PATH);
        if (!file.query_exists(null)) {
            log('Config not found; using defaults.');
            return defaultConfig();
        }
        const [ok, bytes] = file.load_contents(null);
        if (!ok) {
            log('Failed to read config; using defaults.');
            return defaultConfig();
        }
        const json = new TextDecoder().decode(bytes);
        const parsed = JSON.parse(json);
        if (!parsed || typeof parsed !== 'object')
            return defaultConfig();
        parsed.zones ??= [];
        parsed.tabBar ??= defaultConfig().tabBar;
        return parsed;
    } catch (e) {
        log(`Error loading config: ${e}`);
        return defaultConfig();
    }
}

function saveConfig(cfg) {
    try {
        ensureConfigDir();
        const file = Gio.File.new_for_path(CONFIG_PATH);
        const json = JSON.stringify(cfg, null, 2);
        file.replace_contents(
            new TextEncoder().encode(json),
            null,
            false, // make_backup
            Gio.FileCreateFlags.REPLACE_DESTINATION,
            null
        );
        log(`Config saved to ${CONFIG_PATH}`);
        return true;
    } catch (e) {
        log(`Error saving config: ${e}`);
        return false;
    }
}

// ---------- Zone Editor Row ----------

/**
 * ZoneEditorRow
 * Expandable row to edit a single zone.
 * Zone fields: name, monitorIndex, x, y, width, height, gap, isPrimary
 */
const ZoneEditorRow = GObject.registerClass(
class ZoneEditorRow extends Adw.ExpanderRow {
    _init(zoneData, onRemove) {
        super._init({
            title: zoneData?.name || _('Unnamed Zone'),
            subtitle: `X:${zoneData?.x ?? 0}, Y:${zoneData?.y ?? 0}, W:${zoneData?.width ?? 0}, H:${zoneData?.height ?? 0}`,
            expanded: false,
        });

        this._onRemove = onRemove;
        this._zone = {
            name: zoneData?.name ?? '',
            monitorIndex: zoneData?.monitorIndex ?? 0,
            x: zoneData?.x ?? 0,
            y: zoneData?.y ?? 0,
            width: zoneData?.width ?? 0,
            height: zoneData?.height ?? 0,
            gap: zoneData?.gap ?? 0,
            isPrimary: zoneData?.isPrimary ?? false,
        };

        // Action row (right side) — Remove button
        const removeBtn = new Gtk.Button({ label: _('Remove'), valign: Gtk.Align.CENTER });
        removeBtn.add_css_class('destructive-action');
        removeBtn.connect('clicked', () => {
            if (typeof this._onRemove === 'function')
                this._onRemove(this);
        });
        this.add_action(removeBtn);

        // Content grid
        const grid = new Gtk.Grid({ column_spacing: 12, row_spacing: 6, margin_top: 6, margin_bottom: 6 });
        this.add_row(grid);

        // Helper builders
        const labeledEntry = (label, initial, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const entry = new Gtk.Entry({ hexpand: true, text: `${initial ?? ''}` });
            entry.connect('changed', () => onChanged(entry.get_text()));
            row.add_suffix(entry);
            row.activatable_widget = entry;
            return [row, entry];
        };

        const labeledSpin = (label, initial, min, max, step, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const adj = new Gtk.Adjustment({ lower: min, upper: max, step_increment: step, page_increment: step * 10, value: initial });
            const spin = new Gtk.SpinButton({ halign: Gtk.Align.END, adjustment: adj, climb_rate: 1, digits: 0 });
            spin.connect('value-changed', () => onChanged(spin.get_value_as_int()));
            row.add_suffix(spin);
            row.activatable_widget = spin;
            return [row, spin];
        };

        const labeledSwitch = (label, initial, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const sw = new Gtk.Switch({ active: initial, halign: Gtk.Align.END });
            sw.connect('state-set', (_w, state) => {
                onChanged(state);
                return false; // allow default
            });
            row.add_suffix(sw);
            row.activatable_widget = sw;
            return [row, sw];
        };

        // Name
        const [nameRow, nameEntry] = labeledEntry(_('Name'), this._zone.name, (v) => {
            this._zone.name = v;
            this.title = v || _('Unnamed Zone');
        });
        grid.attach(nameRow, 0, 0, 1, 1);

        // Monitor index
        const [monRow, monSpin] = labeledSpin(_('Monitor Index'), this._zone.monitorIndex, 0, 63, 1, (v) => {
            this._zone.monitorIndex = v;
        });
        grid.attach(monRow, 0, 1, 1, 1);

        // X, Y, Width, Height
        const [xRow, xSpin] = labeledSpin(_('X'), this._zone.x, -10000, 10000, 1, (v) => { this._zone.x = v; this._refreshSubtitle(); });
        grid.attach(xRow, 0, 2, 1, 1);
        const [yRow, ySpin] = labeledSpin(_('Y'), this._zone.y, -10000, 10000, 1, (v) => { this._zone.y = v; this._refreshSubtitle(); });
        grid.attach(yRow, 0, 3, 1, 1);
        const [wRow, wSpin] = labeledSpin(_('Width'), this._zone.width, 0, 100000, 1, (v) => { this._zone.width = v; this._refreshSubtitle(); });
        grid.attach(wRow, 0, 4, 1, 1);
        const [hRow, hSpin] = labeledSpin(_('Height'), this._zone.height, 0, 100000, 1, (v) => { this._zone.height = v; this._refreshSubtitle(); });
        grid.attach(hRow, 0, 5, 1, 1);

        // Gap
        const [gapRow, gapSpin] = labeledSpin(_('Gap'), this._zone.gap, 0, 256, 1, (v) => { this._zone.gap = v; });
        grid.attach(gapRow, 0, 6, 1, 1);

        // isPrimary
        const [primRow, primSwitch] = labeledSwitch(_('Primary Zone'), this._zone.isPrimary, (v) => { this._zone.isPrimary = v; });
        grid.attach(primRow, 0, 7, 1, 1);
    }

    _refreshSubtitle() {
        this.subtitle = `X:${this._zone.x}, Y:${this._zone.y}, W:${this._zone.width}, H:${this._zone.height}`;
    }

    getZone() {
        return { ...this._zone };
    }
});

// ---------- Preferences Window ----------

export default class TabbedTilingPrefs extends ExtensionPreferences {
    _createSpinRow(parentGroup, title, initialValue, min, max, step) {
        const row = new Adw.ActionRow({ title });
        const adj = new Gtk.Adjustment({
            lower: min,
            upper: max,
            step_increment: step,
            page_increment: step * 10,
            value: initialValue,
        });
        const spin = new Gtk.SpinButton({
            halign: Gtk.Align.END,
            adjustment: adj,
            climb_rate: 1,
            digits: 0,
        });
        row.add_suffix(spin);
        row.activatable_widget = spin;
        parentGroup.add(row);
        return spin;
    }
    fillPreferencesWindow(window) {
        // Make sure Adw preferences styling is initialized
        Adw.init();

        const cfg = loadConfig();

        const page = new Adw.PreferencesPage();
        window.add(page);

        // Zone Generator Group
        const generatorGroup = new Adw.PreferencesGroup({
            title: _('Zone Generator'),
            description: _('Quickly create a set of horizontal zones for a monitor. This will replace existing zones on the selected monitor.'),
        });
        page.add(generatorGroup);

        const monSpin = this._createSpinRow(generatorGroup, _('Monitor Index'), 0, 0, 16, 1);
        const resWSpin = this._createSpinRow(generatorGroup, _('Monitor Resolution Width'), 1920, 0, 10000, 1);
        const resHSpin = this._createSpinRow(generatorGroup, _('Monitor Resolution Height'), 1080, 0, 10000, 1);
        const xSpin = this._createSpinRow(generatorGroup, _('Start X Coordinate'), 0, 0, 10000, 1);
        const ySpin = this._createSpinRow(generatorGroup, _('Start Y Coordinate'), 0, 0, 10000, 1);
        const numZonesSpin = this._createSpinRow(generatorGroup, _('Number of Zones'), 2, 1, 16, 1);

        const genRow = new Adw.ActionRow();
        const genBtn = new Gtk.Button({ label: _('Generate Zones'), halign: Gtk.Align.CENTER });
        genRow.set_child(genBtn);
        generatorGroup.add(genRow);        

        // Zones group
        const zonesGroup = new Adw.PreferencesGroup({ title: _('Zones'), description: _('Define rectangles for snapping and tabbing.') });
        page.add(zonesGroup);

        // Add New Zone header with button
        const addRow = new Adw.ActionRow({ title: _('Add New Zone'), subtitle: _('Insert a new zone with default values') });
        const addBtn = new Gtk.Button({ label: _('Add') });
        addBtn.connect('clicked', () => this._addZoneRow(null, zonesGroup));
        addRow.add_suffix(addBtn);
        addRow.activatable_widget = addBtn;
        zonesGroup.add(addRow);

        // Existing zones
        this._zoneRows = [];
        for (const z of cfg.zones) {
            this._addZoneRow(z, zonesGroup);
        }

        genBtn.connect('clicked', () => {
            const monitorIndex = monSpin.get_value_as_int();
            const resW = resWSpin.get_value_as_int();
            const resH = resHSpin.get_value_as_int();
            const startX = xSpin.get_value_as_int();
            const startY = ySpin.get_value_as_int();
            const numZones = numZonesSpin.get_value_as_int();

            // Remove existing zones for this monitor
            const rowsToRemove = this._zoneRows.filter(r => r.getZone().monitorIndex === monitorIndex);
            rowsToRemove.forEach(r => {
                zonesGroup.remove(r);
                const index = this._zoneRows.indexOf(r);
                if (index > -1) this._zoneRows.splice(index, 1);
            });

            // Calculate and add new zones
            const availableWidth = resW - startX;
            const zoneWidth = Math.floor(availableWidth / numZones);
            const zoneHeight = resH - startY;

            if (zoneWidth <= 0 || zoneHeight <= 0) {
                this._toast(window, _('Invalid dimensions. Check resolution and start coordinates.'));
                return;
            }

            for (let i = 0; i < numZones; i++) {
                const zoneData = {
                    name: `Monitor ${monitorIndex} Zone ${i + 1}`,
                    monitorIndex, x: startX + (i * zoneWidth), y: startY,
                    width: zoneWidth, height: zoneHeight, gap: 8, isPrimary: (i === 0),
                };
                this._addZoneRow(zoneData, zonesGroup);
            }
            this._toast(window, _(`Generated ${numZones} zones for monitor ${monitorIndex}.`));
        });

        // --- Tab Appearance Group ---
        const tabBarGroup = new Adw.PreferencesGroup({ title: _('Tab Appearance'), description: _('Configure the look and feel of tab bars and tabs.') });
        page.add(tabBarGroup);
        // Merge loaded config with defaults to prevent errors from missing keys
        const cfgTabBar = { ...defaultConfig().tabBar, ...(cfg.tabBar ?? {}) };

        // Height        
        const heightRow = new Adw.ActionRow({ title: _('Height (px)') });
        const heightAdj = new Gtk.Adjustment({ lower: 16, upper: 256, step_increment: 1, value: cfgTabBar.height ?? 32 });
        const heightSpin = new Gtk.SpinButton({ adjustment: heightAdj, digits: 0, halign: Gtk.Align.END });
        heightRow.add_suffix(heightSpin);
        heightRow.activatable_widget = heightSpin;
        tabBarGroup.add(heightRow);
        
        // Background Color
        const colorRow = new Adw.ActionRow({ title: _('Background Color'), subtitle: _('e.g., rgba(30, 30, 30, 0.85)') });
        const colorEntry = new Gtk.Entry({ text: cfgTabBar.backgroundColor ?? 'rgba(30,30,30,0.85)', hexpand: true });
        colorRow.add_suffix(colorEntry);
        colorRow.activatable_widget = colorEntry;
        tabBarGroup.add(colorRow);

        // NEW: Active Tab Background Color
        const activeBgRow = new Adw.ActionRow({
            title: _('Active Tab Background Color'),
            subtitle: _('e.g., rgba(0, 110, 200, 0.85) or #0070f3'),
        });
        const activeBgEntry = new Gtk.Entry({
            text: cfgTabBar.activeBgColor ?? 'rgba(0, 110, 200, 0.8)',
            hexpand: true,
        });
        activeBgRow.add_suffix(activeBgEntry);
        activeBgRow.activatable_widget = activeBgEntry;
        tabBarGroup.add(activeBgRow);

        // NEW: Grouped Tabs Border Color
        const groupBorderRow = new Adw.ActionRow({
            title: _('Grouped Tabs Border Color'),
            subtitle: _('e.g., #4A90E2'),
        });
        const groupBorderEntry = new Gtk.Entry({ text: cfgTabBar.groupBorderColor ?? '#4A90E2', hexpand: true });
        groupBorderRow.add_suffix(groupBorderEntry);
        groupBorderRow.activatable_widget = groupBorderEntry;
        tabBarGroup.add(groupBorderRow);        

        // Corner Radius
        const radiusRow = new Adw.ActionRow({ title: _('Tab Corner Radius (px)') });
        const radiusAdj = new Gtk.Adjustment({ lower: 0, upper: 32, step_increment: 1, value: cfgTabBar.cornerRadius ?? 8 });
        const radiusSpin = new Gtk.SpinButton({ adjustment: radiusAdj, digits: 0, halign: Gtk.Align.END });
        radiusRow.add_suffix(radiusSpin);
        radiusRow.activatable_widget = radiusSpin;
        tabBarGroup.add(radiusRow);

        // Icon Size
        const iconSizeRow = new Adw.ActionRow({ title: _('Icon Size (px)') });
        const iconSizeAdj = new Gtk.Adjustment({ lower: 8, upper: 48, step_increment: 1, value: cfgTabBar.iconSize ?? 16 });
        const iconSizeSpin = new Gtk.SpinButton({ adjustment: iconSizeAdj, digits: 0, halign: Gtk.Align.END });
        iconSizeRow.add_suffix(iconSizeSpin);
        iconSizeRow.activatable_widget = iconSizeSpin;
        tabBarGroup.add(iconSizeRow);

        // Font Size
        const fontSizeRow = new Adw.ActionRow({ title: _('Font Size (pt)') });
        const fontSizeAdj = new Gtk.Adjustment({ lower: 6, upper: 24, step_increment: 1, value: cfgTabBar.fontSize ?? 10 });
        const fontSizeSpin = new Gtk.SpinButton({ adjustment: fontSizeAdj, digits: 0, halign: Gtk.Align.END });
        fontSizeRow.add_suffix(fontSizeSpin);
        fontSizeRow.activatable_widget = fontSizeSpin;
        tabBarGroup.add(fontSizeRow);

        // Spacing
        const spacingRow = new Adw.ActionRow({ title: _('Spacing between Tabs (px)') });
        const spacingAdj = new Gtk.Adjustment({ lower: 0, upper: 32, step_increment: 1, value: cfgTabBar.spacing ?? 4 });
        const spacingSpin = new Gtk.SpinButton({ adjustment: spacingAdj, digits: 0, halign: Gtk.Align.END });
        spacingRow.add_suffix(spacingSpin);
        spacingRow.activatable_widget = spacingSpin;
        tabBarGroup.add(spacingRow);

        // Max Width
        const maxWidthRow = new Adw.ActionRow({ title: _('Max Tab Width (px)') });
        const maxWidthAdj = new Gtk.Adjustment({ lower: 50, upper: 1000, step_increment: 10, value: cfgTabBar.maxWidth ?? 250 });
        const maxWidthSpin = new Gtk.SpinButton({ adjustment: maxWidthAdj, digits: 0, halign: Gtk.Align.END });
        maxWidthRow.add_suffix(maxWidthSpin);
        maxWidthRow.activatable_widget = maxWidthSpin;
        tabBarGroup.add(maxWidthRow);

        // Close Button Size
        const closeButtonSizeRow = new Adw.ActionRow({ title: _('Close Button Size (px)') });
        const closeButtonSizeAdj = new Gtk.Adjustment({ lower: 8, upper: 32, step_increment: 1, value: cfgTabBar.closeButtonSize ?? 12 });
        const closeButtonSizeSpin = new Gtk.SpinButton({ adjustment: closeButtonSizeAdj, digits: 0, halign: Gtk.Align.END });
        closeButtonSizeRow.add_suffix(closeButtonSizeSpin);
        closeButtonSizeRow.activatable_widget = closeButtonSizeSpin;
        tabBarGroup.add(closeButtonSizeRow);

        // --- Tab Behavior Group ---
        const behaviorGroup = new Adw.PreferencesGroup({ title: _('Tab Behavior'), description: _('Configure tab titles and grouping.') });
        page.add(behaviorGroup);

        // Title Source
        const titleSourceRow = new Adw.ActionRow({ title: _('Tab Title Source') });
        const titleModel = new Gtk.StringList();
        titleModel.append(_('Window Title'));
        titleModel.append(_('Application Name'));
        titleModel.append(_('WM_CLASS'));
        const titleDropdown = new Gtk.DropDown({ model: titleModel });
        const titleMap = { 'windowTitle': 0, 'appName': 1, 'wmClass': 2 };
        titleDropdown.set_selected(titleMap[cfgTabBar.titleSource] ?? 0);
        titleSourceRow.add_suffix(titleDropdown);
        titleSourceRow.activatable_widget = titleDropdown;
        behaviorGroup.add(titleSourceRow);

        // Grouping Criteria
        const groupSourceRow = new Adw.ActionRow({ title: _('Tab Grouping Criteria') });
        const groupModel = new Gtk.StringList();
        groupModel.append(_('Application Name'));
        groupModel.append(_('WM_CLASS'));
        const groupDropdown = new Gtk.DropDown({ model: groupModel });
        const groupMap = { 'appName': 0, 'wmClass': 1 };
        groupDropdown.set_selected(groupMap[cfgTabBar.groupingCriteria] ?? 0);
        groupSourceRow.add_suffix(groupDropdown);
        groupSourceRow.activatable_widget = groupDropdown;
        behaviorGroup.add(groupSourceRow);        

        // Sorting Criteria
        const sortSourceRow = new Adw.ActionRow({ title: _('Sorting Criteria') });
        const sortModel = new Gtk.StringList();
        sortModel.append(_('Window Title'));
        sortModel.append(_('Application Name'));
        sortModel.append(_('WM_CLASS'));
        const sortDropdown = new Gtk.DropDown({ model: sortModel });
        const sortMap = { 'windowTitle': 0, 'appName': 1, 'wmClass': 2 };
        sortDropdown.set_selected(sortMap[cfgTabBar.sortingCriteria] ?? 0);
        sortSourceRow.add_suffix(sortDropdown);
        sortSourceRow.activatable_widget = sortDropdown;
        behaviorGroup.add(sortSourceRow);

        // Sorting Order
        const sortOrderRow = new Adw.ActionRow({ title: _('Sorting Order') });
        const orderModel = new Gtk.StringList();
        orderModel.append(_('Ascending'));
        orderModel.append(_('Descending'));
        const orderDropdown = new Gtk.DropDown({ model: orderModel });
        const orderMap = { 'ASC': 0, 'DESC': 1 };
        orderDropdown.set_selected(orderMap[cfgTabBar.sortingOrder] ?? 0);
        sortOrderRow.add_suffix(orderDropdown);
        sortOrderRow.activatable_widget = orderDropdown;
        behaviorGroup.add(sortOrderRow);

        // Footer: Save & Apply (must be added to a PreferencesGroup, not directly to the Page)
        const footer = new Adw.ActionRow();

        const previewBtn = new Gtk.Button({ label: _('Preview Zones') });
        previewBtn.connect('clicked', () => {
            const zones = this._zoneRows.map(r => r.getZone());
            try {
                ensureConfigDir();
                const file = Gio.File.new_for_path(PREVIEW_PATH);
                const json = JSON.stringify(zones);
                file.replace_contents(
                    new TextEncoder().encode(json), null, false,
                    Gio.FileCreateFlags.REPLACE_DESTINATION, null
                );
                this._toast(window, _('Showing zone preview for 5 seconds.'));
            } catch (e) {
                log(`Error saving preview file: ${e}`);
                this._toast(window, _('Could not show preview.'));
            }
        });
        footer.add_prefix(previewBtn);
        const saveBtn = new Gtk.Button({ label: _('Save and Apply') });
        saveBtn.add_css_class('suggested-action');
        saveBtn.connect('clicked', () => {
            const newCfg = this._collectConfig(
                cfg, {
                    heightSpin, colorEntry, radiusSpin, closeButtonSizeSpin,
                    iconSizeSpin, fontSizeSpin, spacingSpin,
                    maxWidthSpin, titleDropdown, groupDropdown,
                    sortDropdown, orderDropdown
                }
            );
            if (saveConfig(newCfg)) {
                this._toast(window, _('Configuration saved.'));
            } else {
                this._toast(window, _('Failed to save configuration.'));
            }
        });
        footer.add_suffix(saveBtn);

        const actionsGroup = new Adw.PreferencesGroup({ title: _('Actions') });
        actionsGroup.add(footer);
        page.add(actionsGroup);
    }

    _addZoneRow(zoneOrNull, zonesGroup) {
        const initial = zoneOrNull ?? {
            name: '',
            monitorIndex: 0,
            x: 0, y: 0, width: 800, height: 600,
            gap: 8,
            isPrimary: false,
        };

        const row = new ZoneEditorRow(initial, (rowSelf) => {
            // remove from UI and local list
            zonesGroup.remove(rowSelf);
            this._zoneRows = this._zoneRows.filter(r => r !== rowSelf);
        });

        this._zoneRows.push(row);
        zonesGroup.add(row);
    }

    _collectConfig(existingCfg, widgets) {
        const zones = this._zoneRows.map(r => r.getZone());
        
        const titleMap = ['windowTitle', 'appName', 'wmClass'];
        const groupMap = ['appName', 'wmClass'];        
        const sortMap = ['windowTitle', 'appName', 'wmClass'];
        const orderMap = ['ASC', 'DESC'];

        const tabBar = {
            ...(existingCfg.tabBar ?? defaultConfig().tabBar),
            height: widgets.heightSpin.get_value_as_int(),
            backgroundColor: widgets.colorEntry.get_text(),
            // NEW: save user-defined colors
            activeBgColor: activeBgEntry.get_text(),
            groupBorderColor: groupBorderEntry.get_text(),            
            cornerRadius: widgets.radiusSpin.get_value_as_int(),
            iconSize: widgets.iconSizeSpin.get_value_as_int(),
            fontSize: widgets.fontSizeSpin.get_value_as_int(),
            spacing: widgets.spacingSpin.get_value_as_int(),
            maxWidth: widgets.maxWidthSpin.get_value_as_int(),
            titleSource: titleMap[widgets.titleDropdown.get_selected()],
            groupingCriteria: groupMap[widgets.groupDropdown.get_selected()],
            closeButtonSize: widgets.closeButtonSizeSpin.get_value_as_int(),
            sortingCriteria: sortMap[widgets.sortDropdown.get_selected()],
            sortingOrder: orderMap[widgets.orderDropdown.get_selected()],
        };

        // Basic validation: drop zones with non-positive size
        const saneZones = zones.filter(z => (z.width > 0 && z.height > 0));

        return { zones: saneZones, tabBar };
    }

    _toast(window, text) {
        // If running inside gnome-extensions-app, we can pop a simple banner using Adw.ToastOverlay if present.
        // Fall back to console.
        try {
            if (!this._overlay) {
                this._overlay = new Adw.ToastOverlay();
                // Wrap current content
                const child = window.get_content();
                window.set_content(this._overlay);
                if (child)
                    this._overlay.set_child(child);
            }
            const toast = new Adw.Toast({ title: text, timeout: 3 });
            this._overlay.add_toast(toast);
        } catch (e) {
            log(`${text} (no toast overlay available)`);
        }
    }
}




===== FILE: ./modules/Tab.js =====
// modules/Tab.js
import St from 'gi://St';
import GObject from 'gi://GObject';
import Pango from 'gi://Pango';
import Clutter from 'gi://Clutter';

export const Tab = GObject.registerClass({
    GTypeName: 'TabbedTiling_Tab',
    Signals: {
        'close-clicked': {},
    },
}, class Tab extends St.Button {
    _init(window, app, config) {
        super._init({
            style_class: 'zone-tab',
            can_focus: true,
            reactive: true,
        });

        this.window = window;
        this.app = app;
        this._config = config; // Save config        

        const box = new St.BoxLayout({
            style_class: 'zone-tab-content',
            x_expand: true,
        });
        this.set_child(box);

        // App Icon
        if (app) {
            const icon = new St.Icon({
                gicon: app.get_icon(),
                style_class: 'zone-tab-app-icon',
                icon_size: this._config.iconSize ?? 16,                
            });
            box.add_child(icon);
        }

        // Title Label
        const label = new St.Label({
            text: this.getTabTitle(),
            y_align: Clutter.ActorAlign.CENTER,
            style_class: 'zone-tab-label',
        });
        // Apply font size from config
        label.style = `font-size: ${this._config.fontSize ?? 10}pt;`;        
        label.clutter_text.set_ellipsize(Pango.EllipsizeMode.END);
        box.add_child(label);

        // Spacer to push the close button to the right
        const spacer = new St.Bin({ x_expand: true });
        box.add_child(spacer);

        // Close Button
        const closeButton = new St.Button({ style_class: 'zone-tab-close-button' });
        closeButton.set_child(new St.Icon({
            icon_name: 'window-close-symbolic',
            icon_size: this._config.closeButtonSize ?? 12,
        }));
        closeButton.connect('clicked', () => this.emit('close-clicked'));
        box.add_child(closeButton);

        // Connect to window title changes to update the tab
        this._titleChangedId = window.connect('notify::title', () => {
            label.set_text(this.getTabTitle());
        });
    }

    getTabTitle() {
        const source = this._config.titleSource ?? 'windowTitle';
        if (source === 'appName' && this.app) return this.app.get_name();
        if (source === 'wmClass') return this.window.get_wm_class();

        // Default to window title with fallbacks
        return this.window.get_title() || (this.app ? this.app.get_name() : null) || this.window.get_wm_class() || 'Untitled';
    }

    getGroupingId() {
        const criteria = this._config.groupingCriteria ?? 'appName';
        if (criteria === 'wmClass') return this.window.get_wm_class();
        // Default to app name
        return this.app ? this.app.get_id() : (this.window.get_wm_class() || 'unknown');
    }

    getSortKey() {
        const criteria = this._config.sortingCriteria ?? 'windowTitle';
        if (criteria === 'appName' && this.app) return this.app.get_name();
        if (criteria === 'wmClass') return this.window.get_wm_class();

        // Default to window title with fallbacks
        return this.window.get_title() || (this.app ? this.app.get_name() : null) || this.window.get_wm_class() || 'Untitled';
    }

    getGroupSortKey() {
        const criteria = this._config.groupingCriteria ?? 'appName';
        if (criteria === 'wmClass') return this.window.get_wm_class() || 'unknown';
        // Default to app name, using the *display name* for sorting
        return this.app ? this.app.get_name() : (this.window.get_wm_class() || 'unknown');
    }

    destroy() {
        if (this._titleChangedId && this.window) {
            try {
                this.window.disconnect(this._titleChangedId);
            } catch (e) { /* ignore */ }
        }
        super.destroy();
    }
});



===== FILE: ./modules/ConfigManager.js =====
// modules/ConfigManager.js
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';

const log = msg => console.log(`[TabbedTiling.ConfigManager] ${msg}`);
const CONFIG_DIR = 'tabbedtiling';
const CONFIG_FILENAME = 'config.json';
const PREVIEW_FILENAME = 'preview.json';

export class ConfigManager {
    constructor() {
        this._configDir = Gio.File.new_for_path(GLib.get_user_config_dir()).get_child(CONFIG_DIR);
        this._configFile = this._configDir.get_child(CONFIG_FILENAME);
        this._previewFile = this._configDir.get_child(PREVIEW_FILENAME);
        this._config = null;

        this._ensureDirExists();
    }

    _ensureDirExists() {
        if (!this._configDir.query_exists(null)) {
            log('Config directory not found, creating it.');
            try {
                this._configDir.make_directory_with_parents(null);
            } catch (e) {
                log(`Error creating config directory: ${e}`);
            }
        }
    }
    
    _getDefaultConfig() {
        return {
            zones: [],
            tabBar: {
                height: 32,
                backgroundColor: 'rgba(30, 30, 30, 0.85)',
                // NEW: user-tunable colors used by TabBar.js
                activeBgColor: 'rgba(0, 110, 200, 0.8)',
                groupBorderColor: '#4A90E2',                
                cornerRadius: 8,
                iconSize: 16,
            fontSize: 10, // in points (pt)
            spacing: 4, // between tabs
            maxWidth: 250, // max width of a single tab
            titleSource: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            groupingCriteria: 'appName', // 'appName', 'wmClass'
            closeButtonSize: 12,
            sortingCriteria: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            sortingOrder: 'ASC', // 'ASC', 'DESC'            
			}
        };
    }

    getConfigFile() {
        return this._configFile;
    }

    getPreviewFile() {
        return this._previewFile;
    }

    load() {
        if (!this._configFile.query_exists(null)) {
            log('Config file not found, creating a default one.');
            this._config = this._getDefaultConfig();
            this.save(this._config);
        } else {
            try {
                const [ok, contents] = this._configFile.load_contents(null);
                if (ok) {
                    this._config = JSON.parse(new TextDecoder().decode(contents));
                } else {
                    throw new Error("Failed to load file contents.");
                }
            } catch (e) {
                log(`Error reading or parsing config file: ${e}. Using default config.`);
                this._config = this._getDefaultConfig();
            }
        }
        return this._config;
    }

    getConfig() {
        return this._config || this.load();
    }

    save(configObject) {
        try {
            const data = JSON.stringify(configObject, null, 2);
            this._configFile.replace_contents(
                data,
                null,
                false,
                Gio.FileCreateFlags.REPLACE_DESTINATION,
                null
            );
            this._config = configObject;
            log('Configuration saved successfully.');
        } catch (e) {
            log(`Error saving configuration: ${e}`);
        }
    }

    savePreviewZones(zones) {
        try {
            const data = JSON.stringify(zones);
            this._previewFile.replace_contents(
                data, null, false,
                Gio.FileCreateFlags.REPLACE_DESTINATION, null
            );
        } catch (e) {
            log(`Error saving preview file: ${e}`);
        }
    }

    loadPreviewZones() {
        try {
            const [ok, contents] = this._previewFile.load_contents(null);
            if (ok) {
                return JSON.parse(new TextDecoder().decode(contents));
            }
        } catch (e) {
            log(`Error loading preview file: ${e}`);
        }
        return null;
    }
}



===== FILE: ./modules/TabBar.js =====
// modules/TabBar.js
import St from 'gi://St';
import GObject from 'gi://GObject';
import Clutter from 'gi://Clutter';
import Shell from 'gi://Shell';
import GLib from 'gi://GLib';

import { Tab } from './Tab.js';

const log = msg => console.log(`[TabbedTiling.TabBar] ${msg}`);

export const TabBar = GObject.registerClass({
    GTypeName: 'TabbedTiling_TabBar',
    Signals: {
        'tab-clicked': { param_types: [GObject.TYPE_OBJECT] }, // Meta.Window
        'tab-removed': { param_types: [GObject.TYPE_OBJECT] }, // Meta.Window
        'tab-moved':   { param_types: [GObject.TYPE_OBJECT] }, // Custom object
    },
}, class TabBar extends St.BoxLayout {
    _init(tabBarConfig) {
        super._init({
            style_class: 'zone-tab-bar',
            reactive: true,
            visible: false,
        });
        
        this.set_height(tabBarConfig.height || 32);
        this.style = `background-color: ${tabBarConfig.backgroundColor};`;
        this._config = tabBarConfig;
        this._tabs = new Map();
        this._windowTracker = Shell.WindowTracker.get_default();

        // Settings-driven colors (with sensible fallbacks)
        this._activeBgColor = String(this._config.activeBgColor ?? 'rgba(0, 110, 200, 0.8)');
        this._groupBorderColor = String(this._config.groupBorderColor ?? '#4A90E2');

        this._tabContainer = new St.BoxLayout({
            style_class: 'zone-tab-container',
            style: `spacing: ${this._config.spacing ?? 4}px;`
        });
        this.add_child(this._tabContainer);        
    }

    /* ---------- tiny helpers to compose inline styles without clobbering ---------- */

    _ensureStyleSlots(tab) {
        // Keep separate parts and join them so set_style never overwrites others
        if (!tab.__ttStyleParts) {
            tab.__ttStyleParts = {
                radius: '',     // e.g., 'border-radius: 8px 8px 0 0;'
                bg: '',         // e.g., 'background-color: rgba(...);'
                border: '',     // e.g., 'border-color: #4A90E2;'
            };
        }
        return tab.__ttStyleParts;
    }

    _applyInlineStyle(tab) {
        const p = this._ensureStyleSlots(tab);
        tab.set_style(`${p.radius}${p.bg}${p.border}`);
    }

    _setRadius(tab, css) {
        const p = this._ensureStyleSlots(tab);
        p.radius = css ? `border-radius: ${css};` : '';
        this._applyInlineStyle(tab);
    }

    _setBg(tab, css) {
        const p = this._ensureStyleSlots(tab);
        p.bg = css ? `background-color: ${css};` : '';
        this._applyInlineStyle(tab);
    }

    _setBorderColor(tab, css) {
        const p = this._ensureStyleSlots(tab);
        p.border = css ? `border-color: ${css};` : '';
        this._applyInlineStyle(tab);
    }

    /* ----------------------------------------------------------------------------- */

    addTab(window) {
        if (this._tabs.has(window)) {
            this.setActiveTab(window);
            return;
        }

        const app = this._windowTracker.get_window_app(window);
        const tab = new Tab(window, app, this._config);
        
        tab.connect('close-clicked', () => this.emit('tab-removed', window));
        tab.connect('button-press-event', (_actor, _event) => {
            try {
                this.emit('tab-clicked', window);
            } catch (e) {
                logError(e, 'Emitting tab-clicked failed');
            }
            return Clutter.EVENT_STOP;
        });

        this._tabs.set(window, tab);
        this._tabContainer.add_child(tab);

        this.reorderTabs();
    }

    removeTab(window) {
        if (this._tabs.has(window)) {
            const tab = this._tabs.get(window);
            this._tabContainer.remove_child(tab);
            tab.destroy();
            this._tabs.delete(window);
            this.reorderTabs();
        }
    }
    
    setActiveTab(window) {
        for (const [win, tab] of this._tabs.entries()) {
            if (win === window) {
                tab.add_style_class_name('active');
                // settings-defined active bg
                this._setBg(tab, this._activeBgColor);
            } else {
                tab.remove_style_class_name('active');
                // clear bg override; fall back to CSS default
                this._setBg(tab, '');
            }
        }
    }

    reorderTabs(zoneName = 'Unknown') {
        const tabs = this._tabContainer.get_children();

        if (tabs.length < 2) {
            this._updateGroupStyles();
            return;
        }

        const sortOrder = (this._config.sortingOrder === 'DESC') ? -1 : 1;

        tabs.sort((a, b) => {
            const groupA = a.getGroupSortKey()?.toLowerCase() ?? '';
            const groupB = b.getGroupSortKey()?.toLowerCase() ?? '';

            if (groupA < groupB) return -1 * sortOrder;
            if (groupA > groupB) return 1 * sortOrder;

            const keyA = a.getSortKey()?.toLowerCase() ?? '';
            const keyB = b.getSortKey()?.toLowerCase() ?? '';

            let result = 0;
            if (keyA < keyB) result = -1;
            if (keyA > keyB) result = 1;

            return result * sortOrder;
        });

        tabs.forEach((tab, index) => {
            this._tabContainer.set_child_at_index(tab, index);
        });

        this._updateGroupStyles();
        this._updateTabSizes();
    }

    getTabs() {
        return this._tabContainer.get_children();
    }

    _updateTabSizes() {
        const children = this._tabContainer.get_children();
        if (children.length === 0) return;

        const availableWidth = this.get_width();
        const maxWidth = this._config.maxWidth ?? 250;

        const widestPreferred = children.reduce((max, c) => {
            return Math.max(max, c.get_preferred_width(-1)[1]);
        }, 0);

        const idealWidth = Math.min(widestPreferred, maxWidth);

        if (idealWidth * children.length > availableWidth) {
            const newWidth = Math.floor(availableWidth / children.length);
            children.forEach(c => c.set_width(newWidth));
        } else {
            children.forEach(c => c.set_width(idealWidth));
        }
    }

    _updateGroupStyles() {
        const children = this._tabContainer.get_children();
        const baseR = Number(this._config.cornerRadius ?? 8);

        if (children.length <= 1) {
            children.forEach(c => {
                c.remove_style_class_name('grouped-start');
                c.remove_style_class_name('grouped-middle');
                c.remove_style_class_name('grouped-end');
                // (1) Single tab → both corners rounded
                this._setRadius(c, `${baseR}px ${baseR}px 0 0`);
                // Not grouped → default border color from CSS, so clear any inline
                this._setBorderColor(c, '');
            });
            return;
        }

        for (let i = 0; i < children.length; i++) {
            const currentTab = children[i];
            const prevTab = children[i - 1] ?? null;
            const nextTab = children[i + 1] ?? null;

            const currentId = currentTab.getGroupingId();
            const prevId = prevTab ? prevTab.getGroupingId() : null;
            const nextId = nextTab ? nextTab.getGroupingId() : null;

            currentTab.remove_style_class_name('grouped-start');
            currentTab.remove_style_class_name('grouped-middle');
            currentTab.remove_style_class_name('grouped-end');

            // Default (solo) → both rounded + default border
            let radiusCss = `${baseR}px ${baseR}px 0 0`;
            let borderColorCss = '';

            if (currentId && currentId === nextId && currentId !== prevId) {
                currentTab.add_style_class_name('grouped-start');
                // (2)(3) First in group → only top-left
                radiusCss = `${baseR}px 0 0 0`;
                borderColorCss = this._groupBorderColor;
            } else if (currentId && currentId === prevId && currentId === nextId) {
                currentTab.add_style_class_name('grouped-middle');
                // (6) Middle in group → no radii
                radiusCss = `0`;
                borderColorCss = this._groupBorderColor;
            } else if (currentId && currentId === prevId && currentId !== nextId) {
                currentTab.add_style_class_name('grouped-end');
                // (4)(5) Last in group → only top-right
                radiusCss = `0 ${baseR}px 0 0`;
                borderColorCss = this._groupBorderColor;
            }

            this._setRadius(currentTab, radiusCss);
            this._setBorderColor(currentTab, borderColorCss);
        }
    }

    destroy() {
        this._tabs.forEach(tab => tab.destroy());
        this._tabs.clear();
        super.destroy();
    }
});




===== FILE: ./modules/Highlighter.js =====
// modules/Highlighter.js
import St from 'gi://St';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import GLib from 'gi://GLib';
import Clutter from 'gi://Clutter';

const PREVIEW_TIMEOUT_MS = 5000; // 5 seconds

export class Highlighter {
    constructor() {
        this._hoverHighlight = null;
        this._previewHighlights = [];
        this._previewTimeoutId = 0;
    }

    _createHighlightActor(styleClass) {
        const actor = new St.Bin({
            style_class: styleClass,
            reactive: false,
            can_focus: false,
            x_expand: true,
            y_expand: true,
        });
        Main.layoutManager.addChrome(actor, { affectsStruts: false });
        actor.set_offscreen_redirect(Clutter.OffscreenRedirect.ALWAYS);
        return actor;
    }

    showHoverHighlight(zone) {
        if (!this._hoverHighlight) {
            this._hoverHighlight = this._createHighlightActor('zone-highlight');
        }

        const monitor = Main.layoutManager.monitors[zone.monitorIndex];
        if (!monitor) return;

        this._hoverHighlight.set_position(monitor.x + zone.x, monitor.y + zone.y);
        this._hoverHighlight.set_size(zone.width, zone.height);
        this._hoverHighlight.show();
    }

    hideHoverHighlight() {
        if (this._hoverHighlight) {
            this._hoverHighlight.hide();
        }
    }

    showAllPreviews(zones) {
        this.destroyPreviews(); // Clear any existing previews

        if (this._previewTimeoutId) {
            GLib.Source.remove(this._previewTimeoutId);
        }

        zones.forEach(zone => {
            const monitor = Main.layoutManager.monitors[zone.monitorIndex];
            if (!monitor) return;

            const actor = this._createHighlightActor('zone-highlight');
            actor.set_position(monitor.x + zone.x, monitor.y + zone.y);
            actor.set_size(zone.width, zone.height);
            actor.show();
            this._previewHighlights.push(actor);
        });

        // Previews automatically hide after a timeout
        this._previewTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, PREVIEW_TIMEOUT_MS, () => {
            this.destroyPreviews();
            this._previewTimeoutId = 0;
            return GLib.SOURCE_REMOVE;
        });
    }

    destroyPreviews() {
        this._previewHighlights.forEach(actor => actor.destroy());
        this._previewHighlights = [];
    }

    destroy() {
        if (this._hoverHighlight) {
            this._hoverHighlight.destroy();
            this._hoverHighlight = null;
        }
        this.destroyPreviews();
    }
}



===== FILE: ./modules/WindowManager.js =====
// modules/WindowManager.js
import Meta from 'gi://Meta';
import Shell from 'gi://Shell';
import GLib from 'gi://GLib';
import Gio from 'gi://Gio';
import Mtk from 'gi://Mtk';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Clutter from 'gi://Clutter';

import { Zone } from './Zone.js';

const log = (msg) => console.log(`[TabbedTiling.WindowManager] ${msg}`);

export class WindowManager {
    constructor(configManager, highlighter) {
        this._configManager = configManager;
        this._highlighter = highlighter;
        this._zones = [];
        this._signalConnections = [];
        this._windowTracker = Shell.WindowTracker.get_default();
        this._loginProxy = null;
    }

    enable() {
        log("DEBUG: enable() called.");
        this.reloadConfiguration();
        this._connectSignals();
        this._snapExistingWindows();
    }

    disable() {
        log("DEBUG: disable() called.");
        this._disconnectSignals();
        this._zones.forEach(zone => zone.destroy());
        this._zones = [];
        this._highlighter.hideHoverHighlight();
    }

    reloadConfiguration() {
        log("DEBUG: reloadConfiguration() called.");
        const config = this._configManager.load();

        this._zones.forEach(zone => zone.destroy());
        this._zones = [];

        config.zones.forEach(zoneData => {
            this._zones.push(new Zone(zoneData, config.tabBar, this._windowTracker));
        });

        log(`Loaded ${this._zones.length} zones.`);
        this._snapExistingWindows();
    }

    _connectSignals() {
        log("DEBUG: _connectSignals() called.");
        const connect = (gobj, name, cb) => {
            const id = gobj.connect(name, cb);
            this._signalConnections.push({ gobj, id });
        };

        connect(global.display, 'grab-op-begin', this._onGrabOpBegin.bind(this));
        connect(global.display, 'grab-op-end', this._onGrabOpEnd.bind(this));
        connect(global.display, 'window-created', this._onWindowCreated.bind(this));
        connect(this._windowTracker, 'tracked-windows-changed', this._onTrackedWindowsChanged.bind(this));
        connect(Main.layoutManager, 'monitors-changed', () => this.reloadConfiguration());

        // Manually create a proxy for LoginManager to handle suspend/resume.
        const LoginManagerIface = `
        <node>
            <interface name="org.freedesktop.login1.Manager">
                <signal name="PrepareForSleep">
                    <arg type="b" name="starting"/>
                </signal>
            </interface>
        </node>`;

        log("DEBUG: Attempting to create LoginManager proxy...");
        try {
            const info = Gio.DBusNodeInfo.new_for_xml(LoginManagerIface);
            const interfaceInfo = info.interfaces.find(i => i.name === 'org.freedesktop.login1.Manager');

            Gio.DBusProxy.new_for_bus(
                Gio.BusType.SYSTEM,
                Gio.DBusProxyFlags.NONE,
                interfaceInfo,
                'org.freedesktop.login1',      // name
                '/org/freedesktop/login1',      // object path
                'org.freedesktop.login1.Manager', // interface name
                null, // cancellable
                (source_object, res) => {
                    try {
                        const proxy = Gio.DBusProxy.new_for_bus_finish(res);
                        log("DEBUG: LoginManager proxy created successfully.");
                        this._loginProxy = proxy;

                        connect(this._loginProxy, 'g-signal', (p, sender, signal, params) => {
                             if (signal === 'PrepareForSleep') {
                                const starting = params.get_child_value(0).get_boolean();
                                if (!starting) {
                                    log("DEBUG: System resumed from sleep, re-snapping windows.");
                                    GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1000, () => {
                                        this._snapExistingWindows();
                                        return GLib.SOURCE_REMOVE;
                                    });
                                }
                             }
                        });
                    } catch (e) {
                        log(`ERROR: Failed to finalize LoginManager proxy or connect signal. Error: ${e.message}`);
                    }
                }
            );
        } catch (e) {
            log(`ERROR: Could not create LoginManager proxy. D-Bus XML may be invalid. Error: ${e.message}`);
        }
    }

    _disconnectSignals() {
        log("DEBUG: _disconnectSignals() called.");
        this._signalConnections.forEach(({ gobj, id }) => {
            try {
                gobj.disconnect(id);
            } catch (e) {
                // Ignore errors if object is already gone
            }
        });
        this._signalConnections = [];
        this._loginProxy = null;
    }

    _isSnappable(window) {
        if (!window || window.is_fullscreen()) return false;
        const type = window.get_window_type();
        return type === Meta.WindowType.NORMAL;
    }

    _onGrabOpBegin(display, window, op) {
        if (!this._isSnappable(window)) return;
        const currentZone = this._findZoneForWindow(window);

        const [, , mods] = global.get_pointer();
        if ((mods & Clutter.ModifierType.CONTROL_MASK) !== 0) {
            window._tilingBypass = true;
            return;
        }
        delete window._tilingBypass;

        if (currentZone) {
            window.raise();
            window._tilingOriginalZone = currentZone;
        }
    }

    _distancePointToRect(x, y, rect) {
        // rect: {x, y, width, height}
        const rx1 = rect.x;
        const ry1 = rect.y;
        const rx2 = rect.x + rect.width;
        const ry2 = rect.y + rect.height;

        // dx/dy are zero if the point is inside the interval
        const dx = (x < rx1) ? (rx1 - x) : (x > rx2) ? (x - rx2) : 0;
        const dy = (y < ry1) ? (ry1 - y) : (y > ry2) ? (y - ry2) : 0;
        // Euclidean distance to the rectangle (0 if inside)
        return Math.hypot(dx, dy);
    }

    _findNearestZoneWithinThreshold(x, y, thresholdPx = 48) {
        // Find the closest zone (by rect distance) on the pointer's monitor,
        // accepting it if the pointer is within `thresholdPx` of the zone.
        const monitorIndex = global.display.get_monitor_index_for_rect(
            new Mtk.Rectangle({ x, y, width: 1, height: 1 })
        );
        const monitor = Main.layoutManager.monitors[monitorIndex];
        if (!monitor) return null;

        let best = { zone: null, dist: Infinity };
        for (const zone of this._zones) {
            if (zone.monitorIndex !== monitorIndex) continue;
            const rect = {
                x: monitor.x + zone.x,
                y: monitor.y + zone.y,
                width: zone.width,
                height: zone.height,
            };
            const d = this._distancePointToRect(x, y, rect);
            if (d < best.dist) {
                best = { zone, dist: d };
            }
        }
        return (best.zone && best.dist <= thresholdPx) ? best.zone : null;
    }

    _onGrabOpEnd(display, window) {
        if (window._tilingBypass) {
            delete window._tilingBypass;
            this._highlighter.hideHoverHighlight();
            return;
        }

        if (!this._isSnappable(window)) return;

        this._highlighter.hideHoverHighlight();

        const [pointerX, pointerY] = global.get_pointer();
        // 1) Try direct hit
        let targetZone = this._findZoneAt(pointerX, pointerY);

        const originalZone = window._tilingOriginalZone;
        if (originalZone) {
            delete window._tilingOriginalZone;
        }

        // If we dragged out of all zones (e.g., to the very top pixel),
        // 2) Try nearest zone within a small threshold
        if (!targetZone) {
            targetZone = this._findNearestZoneWithinThreshold(pointerX, pointerY, 48);
        }

        // 3) If still nothing, and we had an original zone on the same monitor,
        //    snap back to the original zone (graceful fallback).
        if (!targetZone && originalZone) {
            const monitorAtDrop = global.display.get_monitor_index_for_rect(
                new Mtk.Rectangle({ x: pointerX, y: pointerY, width: 1, height: 1 })
            );
            if (monitorAtDrop === originalZone.monitorIndex) {
                targetZone = originalZone;
            }
        }

        if (originalZone && targetZone && targetZone !== originalZone) {
            originalZone.unsnapWindow(window);
        }

        if (targetZone) {
            targetZone.snapWindow(window);
        }
    }

    _onWindowCreated(display, window) {
        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 200, () => {
            if (!window || !this._isSnappable(window)) return GLib.SOURCE_REMOVE;

            const monitorIndex = window.get_monitor();
            const primaryZone = this._zones.find(z =>
                z.monitorIndex === monitorIndex && z.isPrimary
            );

            if (primaryZone) {
                log(`New window "${window.get_title()}" snapping to primary zone.`);
                primaryZone.snapWindow(window);
            }
            return GLib.SOURCE_REMOVE;
        });
    }

    _onTrackedWindowsChanged() {
        const trackedWindows = new Set(global.get_window_actors().map(a => a.get_meta_window()));

        for (const zone of this._zones) {
            const snappedWindows = zone.getSnappedWindows();
            for (const window of snappedWindows) {
                if (!trackedWindows.has(window)) {
                    log(`Window "${window.get_title()}" is no longer tracked, removing from zone "${zone.name}".`);
                    zone.unsnapWindow(window);
                }
            }
        }
    }

    _snapExistingWindows() {
        log("DEBUG: _snapExistingWindows() called.");
        const allWindows = global.get_window_actors().map(a => a.get_meta_window());
        allWindows.forEach(window => {
            if (this._isSnappable(window)) {
                let targetZone = this._findZoneForWindow(window);

                if (!targetZone) {
                    targetZone = this._findBestZoneForWindow(window);
                }

                if (targetZone) {
                    targetZone.snapWindow(window);
                }
            }
        });
        this._zones.forEach(zone => zone.reorderTabs());
        this._logZoneStates();
    }

    _logZoneStates() {
        log('--- Final Zone States ---');
        this._zones.forEach(zone => {
            const tabs = zone.getTabs();
            if (tabs.length === 0) return;

            log(`Zone "${zone.name}" contains ${tabs.length} tabs:`);
            tabs.forEach((tab, index) => {
                const appName = tab.app ? tab.app.get_name() : 'N/A';
                const windowTitle = tab.window.get_title() || 'N/A';
                const wmClass = tab.window.get_wm_class() || 'N/A';
                log(`  - [${index}] App='${appName}', Title='${windowTitle}', WMClass='${wmClass}'`);
            });
        });
    }

    _findBestZoneForWindow(window) {
        if (!window) return null;
        const frame = window.get_frame_rect();
        const centerX = frame.x + frame.width / 2;
        const centerY = frame.y + frame.height / 2;
        return this._findZoneAt(centerX, centerY);
    }

    _findZoneAt(x, y) {
        const monitorIndex = global.display.get_monitor_index_for_rect(
            new Mtk.Rectangle({ x, y, width: 1, height: 1 })
        );
        const monitor = Main.layoutManager.monitors[monitorIndex];
        if (!monitor) return null;

        for (const zone of this._zones) {
            if (zone.monitorIndex !== monitorIndex) continue;

            const zoneRect = {
                x: monitor.x + zone.x,
                y: monitor.y + zone.y,
                width: zone.width,
                height: zone.height,
            };

            if (x >= zoneRect.x && x <= zoneRect.x + zoneRect.width &&
                y >= zoneRect.y && y <= zoneRect.y + zoneRect.height) {
                return zone;
            }
        }
        return null;
    }

    _findZoneForWindow(window) {
        return this._zones.find(zone => zone.containsWindow(window));
    }
}



===== FILE: ./modules/Zone.js =====
// modules/Zone.js
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Meta from 'gi://Meta';
import GLib from 'gi://GLib';

import { TabBar } from './TabBar.js';

const log = msg => console.log(`[TabbedTiling.Zone] ${msg}`);

export class Zone {
    constructor(zoneData, tabBarConfig, windowTracker) {
        // Copy all properties from the config
        Object.assign(this, zoneData);

        this._snappedWindows = new Set();
        this._windowTracker = windowTracker;

        this._tabBar = new TabBar(tabBarConfig);
        this._tabBar.connect('tab-clicked', (actor, window) => this.activateWindow(window));
        // When the close button on a tab is clicked, the 'tab-removed' signal is emitted.
        // We connect this to an action that closes the actual window.
        this._tabBar.connect('tab-removed', (actor, window) => {
            window.delete(global.get_current_time());
        });
        this._tabBar.connect('tab-moved', (actor, { fromZone, toZone, window }) => {
            // This is a placeholder for inter-zone dragging logic
        });

        this._updateTabBarPosition();
        Main.layoutManager.addChrome(this._tabBar);
    }

    get monitor() {
        return Main.layoutManager.monitors[this.monitorIndex];
    }

    get rect() {
        if (!this.monitor) return null;
        return {
            x: this.monitor.x + this.x,
            y: this.monitor.y + this.y,
            width: this.width,
            height: this.height,
        };
    }

    _updateTabBarPosition() {
        if (!this.rect) return;
        const tabBarHeight = this._tabBar.height;
        this._tabBar.set_position(
            this.rect.x + this.gap,
            this.rect.y + this.gap
        );
        this._tabBar.set_size(this.rect.width - (2 * this.gap), tabBarHeight);
    }

    _ensureUntiled(window) {
        // Some apps (including GNOME Terminal) can be in a "tiled" state.
        // Just unmaximizing is not always enough; explicitly clear tiling.
        try {
            if (window.get_maximized()) {
                window.unmaximize(Meta.MaximizeFlags.BOTH);
            }
            if (typeof window.get_tile_type === 'function' &&
                window.get_tile_type() !== Meta.TileMode.NONE &&
                typeof window.tile === 'function') {
                window.tile(Meta.TileMode.NONE);
            }
        } catch (_) {
            // Ignore if not supported on this shell version.
        }
    }

    _twoStepMoveResize(window, x, y, w, h) {
        // Some clients ignore a single move+resize request (especially with increments).
        // Do a two-step: move first, then resize on idle, then a final move_resize as a fallback.
        window.move_frame(true, x, y);
        GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {
            window.move_resize_frame(true, x, y, w, h);
            return GLib.SOURCE_REMOVE;
        });
    }

    /**
     * Try to respect WM_NORMAL_HINTS resize increments for apps like GNOME Terminal.
     * There isn't a stable public GJS API to read the raw size hints directly,
     * so we use a conservative heuristic:
     *  - Detect well-known terminal classes.
     *  - Apply typical increment values observed via `xprop` (width 10px, height 19px)
     *    with base sizes (68x101). These may vary slightly with theme/fonts, but
     *    will usually be accepted by the client, ensuring snaps “stick”.
     *
     * If the window doesn't match, we return the requested size unchanged.
     */
    _quantizeToSizeHints(window, requestedW, requestedH) {
        try {
            const klass = (window.get_wm_class && window.get_wm_class()) || '';
            const isTerminal =
                klass.toLowerCase().includes('gnome-terminal') ||
                klass.toLowerCase().includes('org.gnome.terminal') ||
                klass.toLowerCase().includes('kgx') ||                      // GNOME Console
                klass.toLowerCase().includes('konsole') ||                  // KDE Konsole
                klass.toLowerCase().includes('alacritty') ||
                klass.toLowerCase().includes('kitty') ||
                klass.toLowerCase().includes('xterm');

            if (!isTerminal)
                return [requestedW, requestedH];

            // Defaults derived from your xprop for GNOME Terminal:
            //   base size: 68x101, increments: 10x19
            // NOTE: If your terminal uses different font metrics, tweak here.
            const baseW = 68;
            const baseH = 101;
            const incW  = 10;
            const incH  = 19;

            // Snap down to the nearest valid multiple so the client always accepts it.
            const adjW = baseW + Math.max(0, Math.floor((requestedW - baseW) / incW)) * incW;
            const adjH = baseH + Math.max(0, Math.floor((requestedH - baseH) / incH)) * incH;
            return [adjW, adjH];
        } catch (_e) {
            return [requestedW, requestedH];
        }
    }

    snapWindow(window) {
        if (!this.rect) return;

        // Ensure not maximized/tiled before attempting to move.
        this._ensureUntiled(window);

        const tabBarHeight = this._tabBar.height;
        const newX = this.rect.x + this.gap;
        const newY = this.rect.y + this.gap + tabBarHeight; // Position window below tab bar
        let newWidth = this.rect.width - (2 * this.gap);
        let newHeight = this.rect.height - (2 * this.gap) - tabBarHeight;

        // Respect client resize increments when applicable (e.g., terminals).
        // This prevents Mutter from ignoring our move/resize when sizes are invalid.
        const [adjW, adjH] = this._quantizeToSizeHints(window, newWidth, newHeight);
        newWidth = adjW;
        newHeight = adjH;

        // Perform a two-step move+resize to coax stubborn clients (e.g., GNOME Terminal).
        this._twoStepMoveResize(window, newX, newY, newWidth, newHeight);
        // Final belt-and-suspenders attempt with user_op=false in case the WM treats it differently.
        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 50, () => {
            try {
                window.move_resize_frame(false, newX, newY, newWidth, newHeight);
            } catch (_) {}
            return GLib.SOURCE_REMOVE;
        });

        if (!this._snappedWindows.has(window)) {
            this._snappedWindows.add(window);
            window._tilingZoneId = this.name; // Tag the window
            this._tabBar.addTab(window);
        }

        this.activateWindow(window);
        this._updateVisibility();
    }

    unsnapWindow(window) {
        if (this._snappedWindows.has(window)) {
            this._snappedWindows.delete(window);
            delete window._tilingZoneId;
            this._tabBar.removeTab(window);

            // Activate the next tab if available
            if (this._snappedWindows.size > 0) {
                const nextWindow = this._snappedWindows.values().next().value;
                this.activateWindow(nextWindow);
            }
        }
        this._updateVisibility();
    }

    activateWindow(window) {
        if (this._snappedWindows.has(window)) {
            window.activate(global.get_current_time());
            this._tabBar.setActiveTab(window);
        }
    }

    containsWindow(window) {
        return this._snappedWindows.has(window);
    }

    _updateVisibility() {
        const shouldBeVisible = this._snappedWindows.size > 0;
        if (this._tabBar.visible !== shouldBeVisible) {
            this._tabBar.visible = shouldBeVisible;
        }
    }

    reorderTabs() {
        this._tabBar.reorderTabs(this.name);
    }

    getSnappedWindows() {
        // Return a copy to allow safe iteration while the original set might be modified.
        return new Set(this._snappedWindows);
    }

    getTabs() {
        return this._tabBar.getTabs();
    }

    destroy() {
        // Unsnap all windows before destroying
        [...this._snappedWindows].forEach(win => this.unsnapWindow(win));
        if (this._tabBar) {
            this._tabBar.destroy();
            this._tabBar = null;
        }
    }
}



===== FILE: ./metadata.json =====
{
"name": "Tabbed Tiling",
"description": "A tiling window manager for GNOME Shell that uses tabs to manage windows within predefined zones.",
"uuid": "tabbedtiling@george.com",
"version": 1,
"shell-version": ["48"],
"url": "https://github.com/george/tabbed-tiling",
"session-modes": ["user"],
"settings-schema": "org.gnome.shell.extensions.tabbedtiling"
}




===== FILE: ./instructions.txt =====
# **GNOME Extension Specification – Tabbed Tiling (X11 only)**
Name: TabbedTiling

## 1. Configuration

- Zones and settings are defined in a config file: `~/.config/tabbedtiling/config.json`
- No settings are stored in `gsettings`.    
- Config file is **read once at extension startup**.    
- Settings changed in the UI take effect when **Save** is pressed.    
- Fresh install starts with **no zones defined**.
- There is a preview button on the setting page for the zone creation only. When pressed, zones become visible with a color at 50% opacity to show user where the zones are.
## 2. Zone Management

- Zones are defined using fixed screen coordinates relative to the **full framebuffer** (not workarea).    
    - Properties: `x`, `y` (top-left), `width`, `height`.        
- Each monitor can have its own independent set of zones.    
- Multiple monitors are supported; zones are per-monitor but they don't have to be defined for each monitor if not needed.    
- One zone per monitor can be marked as the **primary zone**.    
- No workspace/virtual desktop support. If enabled, zones only apply to the **primary workspace**.
- Zones can only be created horizontally, so they are right next to each other.
- When extension starts the first time it has no zones defined. User can use the settings to add a zone by entering manual values for coordinates and etc. 
- When entering values to define zones, start with the full resolution for each monitor you want to configure. Then, let the user select how many zones they need—there is no need to click on a button to create new zones. The calculation should be semi-automatic. For example, if you define a resolution of 1024x768, you will need to manually enter the starting coordinates for X and Y. The height and width for all zones will then be automatically calculated based on the resolution. For vertical values, the height is determined by subtracting the starting Y coordinate from the resolution height. So if Y is 68 and the resolution height is 768, then all zones will have Y: 68 and height: 700. For horizontal values, subtract the starting X coordinate from the resolution width. If X is 50 and the resolution width is 1000, you have 950 pixels remaining. These 950 pixels are then divided into as many equal parts as the number of zones specified earlier.
## 3. Gaps

- Each zone has a **gap value** (`0+`) applied like padding inside the zone.    
- Gap does not change zone size/position; windows are inset.    
- Same gap on all sides within a zone.    
- Gap setting is per-zone.
## 4. Tab Bars

- Each zone has a **tab bar**:    
    - Positioned at the zone’s top (x,y minus gap).        
    - Configurable `height`.        
    - Shares the same width as the zone.
- Tabs and windows have no spacing between them; windows and tab bar touch directly,The gap that is defined is above the tab bar.   
- Tab bar has a configurable **background color and opacity** from settings .    
- Tab appearance:    
    - Adjustable Rounded top-left and top-right corners (single setting).        
    - Adjustable icon and text size.        
    - Adjustable Tab spacing.        
- All tabs have a max size settings that apply to all tabs equally. Tabs cannot get wider that this setting. All tabs are equal width.
- If tabs exceed available space in tab bar, tab width decreases until all fit.    

## 5. Windows & Snapping

- Windows snap to zones when dragged over them:    
    - The hovered zone highlights (50% opacity).        
    - On release, the window resizes to zone dimensions minus gaps and tab bar height.
- Ctrl+drag prevents snapping (creates a **floating window**).    
- Floating windows:    
    - Layered above zones (z-index).        
    - Not managed by zones/tabs.        
    - Follow system’s natural window stacking.        
- Child dialogs and system tray popups do not snap or create tabs.    
- Resizing a snapped window does not unsnap it. It keeps snapped status until re-dragged. Also, when resizing, the mouse pointer doesn't activate the zone highlighting/snapping when moved over other ziones.    
- Maximized windows cover the whole screen, hiding zones and tabs.
- When computer comes back from sleep, we have to make sure that snapping stays the same as it was before sleeping.
- When extension starts, all windows will snap into place automatically child windows or windows open from systray.

## 6. Tabs & Behavior

- Every snapped window has a tab, even if only one window is in the zone.    
- Clicking a tab activates its window.    
- Tab contents:    
    - Title = configurable source (`WM_CLASS class/instance`, `_NET_WM_PID`, desktop file, window role, etc.).        
    - Title fallback chain: window title → app name → WM_CLASS.        
    - Icon = application’s icon.        
- Tabs support:    
    - Moving between tab bars (window moves zones when its tab moves).        
    - Close button: closes app → removes tab. If close fails, tab is removed and window floats.        
    - After tab close, right neighbor is activated; fallback = left; fallback = none.
        
- Tabs can be **Normal** or **Grouped**:    
    - Tab groups mean that all of the same type of tabs have a dynamically created unique bg color.
    - Grouping is automatic for multiple windows of the same application in a zone.        
    - Groups are only visual; tabs remain individually manageable.        
    - Groups cannot span zones.        
    - Grouping criteria are user-defined in settings (same as tab title sources).        
    - Dynamic regrouping occurs if window title/class changes or if extension is turned on or if computer comes back from sleep unless tabs are already groupped.  
- Tabs should always auto arrange in each zone based on these rules:
	- They should be sorted alphabetically ASC
	- Windows of the same kind (defined in setting) should be groupped together.

-Autoarrange function should be called at the minimum in the following cases:
	- When extension launches
	- When computer comes back from sleep or lock screen
	- When a new window is dragged into a zone.
	- When a window is dragged out of a zone.

## 7. Window & App Launch Behavior

- New applications launch in the **primary zone** of the active monitor.    
- New window automatically gets a tab and is made active.    
- Selecting an app:    
    - From **Alt+Tab** → activates corresponding tab/window.        
    - From **Dash-to-Dock** → activates window and tab in its zone.        

## 8. Input & Controls

- Tab switching is **mouse-only** (no keyboard shortcuts are needed).    
- Dragging a window without Ctrl shows zone highlight and snaps on release; with Ctrl, no highlight and no snapping.    

## 9. Compatibility

- GNOME 48 targeted, with optional support for GNOME 46–47.    
- **X11 only**. No Wayland support.



