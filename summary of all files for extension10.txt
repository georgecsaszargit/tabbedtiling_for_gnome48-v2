

===== FILE: ./stylesheet.css =====
/* stylesheet.css */
/* Radii and colors for active/grouped are driven inline from JS to beat theme rules. */

.zone-highlight {
    background-color: rgba(100, 100, 255, 0.5);
    border: 2px solid rgba(200, 200, 255, 0.8);
    border-radius: 8px;
    transition-duration: 150ms;
}

.zone-tab-bar {
    padding: 0 4px;
}

.zone-tab {
    background-color: rgba(60, 60, 60, 0.9);
    border: 1px solid #222;
    border-bottom-width: 0;
    padding: 2px 8px;
    margin: 0 2px;
    transition-duration: 150ms;
    overflow: hidden; /* ensures child visuals don’t override radius */
}

.zone-tab:hover {
    background-color: rgba(80, 80, 80, 0.9);
}

.zone-tab:active,
.zone-tab:focus,
.zone-tab.active {
    /* The final background-color is set inline for the active tab from settings.
       We still tweak text/border contrast here. */
    color: white;
    border-color: #555;
}

.zone-tab-content {
    spacing: 6px;
}

.zone-tab-app-icon { }
.zone-tab-label { }

.zone-tab-close-button {
    background-color: transparent;
    border: none;
    padding: 2px;
    border-radius: 99px;
}

.zone-tab-close-button:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

/* --- Grouping Styles --- */
/* Thickness and glow stay in CSS; color itself comes from inline JS (settings). */
.zone-tab.grouped-start,
.zone-tab.grouped-middle,
.zone-tab.grouped-end {
    border-top-width: 3px;
    box-shadow: 0 0 4px rgba(74, 144, 226, 0.45);
}

.zone-tab.grouped-start {
    border-left-width: 3px;
    border-right-width: 0;
    margin-right: 0;
}

.zone-tab.grouped-middle {
    border-left-width: 0;
    border-right-width: 0;
    margin-left: 0;
    margin-right: 0;
}

.zone-tab.grouped-end {
    border-right-width: 3px;
    border-left-width: 0;
    margin-left: 0;
}

/* Slightly stronger glow when active (color stays consistent with inline border-color) */
.zone-tab.active.grouped-start,
.zone-tab.active.grouped-middle,
.zone-tab.active.grouped-end {
    box-shadow: 0 0 6px rgba(74, 144, 226, 0.60);
}




===== FILE: ./extension.js =====
// extension.js
import { Extension } from 'resource:///org/gnome/shell/extensions/extension.js';
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';

import { WindowManager } from './modules/WindowManager.js';
import { ConfigManager } from './modules/ConfigManager.js';
import { Highlighter } from './modules/Highlighter.js';

const log = msg => console.log(`[TabbedTiling] ${msg}`);

export default class TabbedTilingExtension extends Extension {
    constructor(metadata) {
        super(metadata);
        this._configManager = null;
        this._windowManager = null;
        this._highlighter = null;
        this._configFileMonitor = null;
        this._previewFileMonitor = null;
    }

    enable() {
        // Don’t render tabs/overlays on lock screen or other non-user modes.
        // This prevents tab bars showing above the lock UI.
        if (Main.sessionMode.currentMode !== 'user') {
            return;
        }    
        log('Enabling...');

        this._configManager = new ConfigManager();
        this._highlighter = new Highlighter();
        this._windowManager = new WindowManager(this._configManager, this._highlighter);

        try {
            this._windowManager.enable();
            this._monitorConfigFiles();
            log('Enabled successfully.');
        } catch (e) {
            log(`Error during enable: ${e}`);
            this.disable();
        }
    }

    disable() {
        log('Disabling...');

        if (this._configFileMonitor) {
            this._configFileMonitor.cancel();
            this._configFileMonitor = null;
        }
        if (this._previewFileMonitor) {
            this._previewFileMonitor.cancel();
            this._previewFileMonitor = null;
        }

        if (this._windowManager) {
            this._windowManager.disable();
            this._windowManager = null;
        }

        if (this._highlighter) {
            this._highlighter.destroy();
            this._highlighter = null;
        }

        this._configManager = null;
        log('Disabled.');
    }

    _monitorConfigFiles() {
        // Monitor the main config file for changes from the preferences window
        const configFile = this._configManager.getConfigFile();
        this._configFileMonitor = configFile.monitor(Gio.FileMonitorFlags.NONE, null);
        this._configFileMonitor.connect('changed', (monitor, file, otherFile, eventType) => {
            if (eventType === Gio.FileMonitorEvent.CHANGES_DONE_HINT) {
                log('Config file changed, reloading zones...');
                GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {
                    this._windowManager.reloadConfiguration();
                    return GLib.SOURCE_REMOVE;
                });
            }
        });

        // Monitor the preview file for requests from the preferences window
        const previewFile = this._configManager.getPreviewFile();
        this._previewFileMonitor = previewFile.monitor(Gio.FileMonitorFlags.NONE, null);
        this._previewFileMonitor.connect('changed', (monitor, file, otherFile, eventType) => {
            if (eventType === Gio.FileMonitorEvent.CHANGES_DONE_HINT) {
                log('Preview file changed, showing preview...');
                const zones = this._configManager.loadPreviewZones();
                if (zones) {
                    this._highlighter.showAllPreviews(zones);
                }
            }
        });
    }
}



===== FILE: ./prefs.js =====
// prefs.js — TabbedTiling preferences (GNOME 48 / GJS)
// Works on X11; uses Adw, Gtk, GObject. Stores config in ~/.config/tabbedtiling/config.json

import Gio from 'gi://Gio';
import Gtk from 'gi://Gtk';
import Adw from 'gi://Adw';
import GLib from 'gi://GLib';
import GObject from 'gi://GObject';
import Gdk from 'gi://Gdk';

import { ExtensionPreferences, gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';

// If you have a local ConfigManager module, you can keep using it.
// This file includes minimal file I/O, so ConfigManager is optional.
// import { ConfigManager } from './modules/ConfigManager.js';

const log = (msg) => console.log(`[TabbedTilingPrefs] ${msg}`);

const CONFIG_DIR = GLib.build_filenamev([GLib.get_home_dir(), '.config', 'tabbedtiling']);
const CONFIG_PATH = GLib.build_filenamev([CONFIG_DIR, 'config.json']);
const PREVIEW_PATH = GLib.build_filenamev([CONFIG_DIR, 'preview.json']);

function ensureConfigDir() {
    try {
        const f = Gio.File.new_for_path(CONFIG_DIR);
        if (!f.query_exists(null))
            f.make_directory_with_parents(null);
    } catch (e) {
        log(`Failed to ensure config dir: ${e}`);
    }
}

function defaultConfig() {
    return {
        zones: [],
        tabBar: {
            height: 32,
            backgroundColor: 'rgba(30,30,30,0.85)',
            // Color keys already used by TabBar/ConfigManager
            activeBgColor: 'rgba(0, 110, 200, 0.8)',
            groupBorderColor: '#4A90E2',
            cornerRadius: 8,
            iconSize: 16,
            fontSize: 10, // in points (pt)
            spacing: 4, // between tabs
            maxWidth: 250, // max width of a single tab
            titleSource: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            groupingCriteria: 'appName', // 'appName', 'wmClass'
            closeButtonSize: 12,    
            sortingCriteria: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            sortingOrder: 'ASC', // 'ASC', 'DESC'                    
        },
        // NEW: persisted defaults for the Zone Generator UI
        zoneGenerator: {
            monitorIndex: 0,
            resW: 1920,
            resH: 1080,
            startX: 0,
            startY: 0,
            numZones: 2,
        },        
    };
}

function loadConfig() {
    try {
        const file = Gio.File.new_for_path(CONFIG_PATH);
        if (!file.query_exists(null)) {
            log('Config not found; using defaults.');
            return defaultConfig();
        }
        const [ok, bytes] = file.load_contents(null);
        if (!ok) {
            log('Failed to read config; using defaults.');
            return defaultConfig();
        }
        const json = new TextDecoder().decode(bytes);
        const parsed = JSON.parse(json);
        if (!parsed || typeof parsed !== 'object')
            return defaultConfig();
        parsed.zones ??= [];
        parsed.tabBar ??= defaultConfig().tabBar;
        return parsed;
    } catch (e) {
        log(`Error loading config: ${e}`);
        return defaultConfig();
    }
}

function saveConfig(cfg) {
    try {
        ensureConfigDir();
        const file = Gio.File.new_for_path(CONFIG_PATH);
        const json = JSON.stringify(cfg, null, 2);
        file.replace_contents(
            new TextEncoder().encode(json),
            null,
            false, // make_backup
            Gio.FileCreateFlags.REPLACE_DESTINATION,
            null
        );
        log(`Config saved to ${CONFIG_PATH}`);
        return true;
    } catch (e) {
        log(`Error saving config: ${e}`);
        return false;
    }
}

// ---------- Zone Editor Row ----------

/**
 * ZoneEditorRow
 * Expandable row to edit a single zone.
 * Zone fields: name, monitorIndex, x, y, width, height, gaps{top,right,bottom,left}, isPrimary
 */
const ZoneEditorRow = GObject.registerClass(
class ZoneEditorRow extends Adw.ExpanderRow {
    _init(zoneData, onRemove) {
        super._init({
            title: zoneData?.name || _('Unnamed Zone'),
            subtitle: `X:${zoneData?.x ?? 0}, Y:${zoneData?.y ?? 0}, W:${zoneData?.width ?? 0}, H:${zoneData?.height ?? 0}`,
            expanded: false,
        });

        this._onRemove = onRemove;
        // Normalize legacy 'gap' into per-side gaps if present
        const legacyGap = (zoneData?.gap ?? null);
        const normGaps = (zoneData?.gaps && typeof zoneData.gaps === 'object')
            ? {
                top: Number(zoneData.gaps.top ?? 8),
                right: Number(zoneData.gaps.right ?? 8),
                bottom: Number(zoneData.gaps.bottom ?? 8),
                left: Number(zoneData.gaps.left ?? 8),
              }
            : {
                top: Number(legacyGap ?? 8),
                right: Number(legacyGap ?? 8),
                bottom: Number(legacyGap ?? 8),
                left: Number(legacyGap ?? 8),
              };

        this._zone = {
            name: zoneData?.name ?? '',
            monitorIndex: zoneData?.monitorIndex ?? 0,
            x: zoneData?.x ?? 0,
            y: zoneData?.y ?? 0,
            width: zoneData?.width ?? 0,
            height: zoneData?.height ?? 0,
            gaps: normGaps,
            isPrimary: zoneData?.isPrimary ?? false,
        };

        // Action row (right side) — Remove button
        const removeBtn = new Gtk.Button({ label: _('Remove'), valign: Gtk.Align.CENTER });
        removeBtn.add_css_class('destructive-action');
        removeBtn.connect('clicked', () => {
            if (typeof this._onRemove === 'function')
                this._onRemove(this);
        });
        this.add_action(removeBtn);

        // Content grid
        const grid = new Gtk.Grid({ column_spacing: 12, row_spacing: 6, margin_top: 6, margin_bottom: 6 });
        this.add_row(grid);

        // Helper builders
        const labeledEntry = (label, initial, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const entry = new Gtk.Entry({ hexpand: true, text: `${initial ?? ''}` });
            entry.connect('changed', () => onChanged(entry.get_text()));
            row.add_suffix(entry);
            row.activatable_widget = entry;
            return [row, entry];
        };

        const labeledSpin = (label, initial, min, max, step, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const adj = new Gtk.Adjustment({ lower: min, upper: max, step_increment: step, page_increment: step * 10, value: initial });
            const spin = new Gtk.SpinButton({ halign: Gtk.Align.END, adjustment: adj, climb_rate: 1, digits: 0 });
            spin.connect('value-changed', () => onChanged(spin.get_value_as_int()));
            row.add_suffix(spin);
            row.activatable_widget = spin;
            return [row, spin];
        };

        const labeledSwitch = (label, initial, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const sw = new Gtk.Switch({
                active: initial,
                halign: Gtk.Align.END,
                valign: Gtk.Align.CENTER,
                hexpand: false,
                vexpand: false,
            });
            sw.connect('state-set', (_w, state) => {
                onChanged(state);
                return false; // allow default
            });
            row.add_suffix(sw);
            row.activatable_widget = sw;
            return [row, sw];
        };

        // Name
        const [nameRow, nameEntry] = labeledEntry(_('Name'), this._zone.name, (v) => {
            this._zone.name = v;
            this.title = v || _('Unnamed Zone');
        });
        grid.attach(nameRow, 0, 0, 1, 1);

        // Monitor index
        const [monRow, monSpin] = labeledSpin(_('Monitor Index'), this._zone.monitorIndex, 0, 63, 1, (v) => {
            this._zone.monitorIndex = v;
        });
        grid.attach(monRow, 0, 1, 1, 1);

        // X, Y, Width, Height
        const [xRow, xSpin] = labeledSpin(_('X'), this._zone.x, -10000, 10000, 1, (v) => { this._zone.x = v; this._refreshSubtitle(); });
        grid.attach(xRow, 0, 2, 1, 1);
        const [yRow, ySpin] = labeledSpin(_('Y'), this._zone.y, -10000, 10000, 1, (v) => { this._zone.y = v; this._refreshSubtitle(); });
        grid.attach(yRow, 0, 3, 1, 1);
        const [wRow, wSpin] = labeledSpin(_('Width'), this._zone.width, 0, 100000, 1, (v) => { this._zone.width = v; this._refreshSubtitle(); });
        grid.attach(wRow, 0, 4, 1, 1);
        const [hRow, hSpin] = labeledSpin(_('Height'), this._zone.height, 0, 100000, 1, (v) => { this._zone.height = v; this._refreshSubtitle(); });
        grid.attach(hRow, 0, 5, 1, 1);

        // Per-side Gaps
        const [gapTopRow, gapTopSpin] = labeledSpin(_('Gap Top'), this._zone.gaps.top, 0, 256, 1, (v) => { this._zone.gaps.top = v; });
        grid.attach(gapTopRow, 0, 6, 1, 1);
        const [gapRightRow, gapRightSpin] = labeledSpin(_('Gap Right'), this._zone.gaps.right, 0, 256, 1, (v) => { this._zone.gaps.right = v; });
        grid.attach(gapRightRow, 0, 7, 1, 1);
        const [gapBottomRow, gapBottomSpin] = labeledSpin(_('Gap Bottom'), this._zone.gaps.bottom, 0, 256, 1, (v) => { this._zone.gaps.bottom = v; });
        grid.attach(gapBottomRow, 0, 8, 1, 1);
        const [gapLeftRow, gapLeftSpin] = labeledSpin(_('Gap Left'), this._zone.gaps.left, 0, 256, 1, (v) => { this._zone.gaps.left = v; });
        grid.attach(gapLeftRow, 0, 9, 1, 1);

        // isPrimary — place AFTER per-side gaps, at the end of the editor
        const [primRow, primSwitch] = labeledSwitch(_('Primary Zone'), this._zone.isPrimary, (v) => { this._zone.isPrimary = v; });
        primRow.set_margin_top(6);
        // Current rows occupy 0..9 after adding Gap Top/Right/Bottom/Left.
        // Attach Primary Zone on the next free row index to ensure it appears at the end.
        grid.attach(primRow, 0, 10, 1, 1);
    }

    _refreshSubtitle() {
        this.subtitle = `X:${this._zone.x}, Y:${this._zone.y}, W:${this._zone.width}, H:${this._zone.height}`;
    }

    getZone() {
        // Ensure legacy 'gap' is not written back; only persist 'gaps'
        const { name, monitorIndex, x, y, width, height, gaps, isPrimary } = this._zone;
        return { name, monitorIndex, x, y, width, height, gaps, isPrimary };
    }
});

// ---------- Preferences Window ----------

export default class TabbedTilingPrefs extends ExtensionPreferences {
    _rgbaFromString(str, fallbackStr) {
        const rgba = new Gdk.RGBA();
        if (str && rgba.parse(str))
            return rgba;
        const fb = new Gdk.RGBA();
        fb.parse(fallbackStr || 'rgba(0,0,0,1)');
        return fb;
    }
    _colorPickerRow({ parentGroup, title, subtitle, initial }) {
        const row = new Adw.ActionRow({ title, subtitle });
        const dialog = new Gtk.ColorDialog({ with_alpha: true });
        const btn = new Gtk.ColorDialogButton({ dialog, halign: Gtk.Align.END });
        btn.set_rgba(this._rgbaFromString(initial, 'rgba(0,0,0,1)'));
        row.add_suffix(btn);
        row.activatable_widget = btn;
        parentGroup.add(row);
        return btn;
    }
    _createSpinRow(parentGroup, title, initialValue, min, max, step) {
        const row = new Adw.ActionRow({ title });
        const adj = new Gtk.Adjustment({
            lower: min,
            upper: max,
            step_increment: step,
            page_increment: step * 10,
            value: initialValue,
        });
        const spin = new Gtk.SpinButton({
            halign: Gtk.Align.END,
            adjustment: adj,
            climb_rate: 1,
            digits: 0,
        });
        row.add_suffix(spin);
        row.activatable_widget = spin;
        parentGroup.add(row);
        return spin;
    }
    fillPreferencesWindow(window) {
        // Make sure Adw preferences styling is initialized
        Adw.init();

        const cfg = loadConfig();
        const genDefaults = { ...defaultConfig().zoneGenerator, ...(cfg.zoneGenerator ?? {}) };

        const page = new Adw.PreferencesPage();
        window.add(page);

        // Zone Generator Group
        const generatorGroup = new Adw.PreferencesGroup({
            title: _('Zone Generator'),
            description: _('Quickly create a set of horizontal zones for a monitor. This will replace existing zones on the selected monitor.'),
        });
        page.add(generatorGroup);

        const monSpin      = this._createSpinRow(generatorGroup, _('Monitor Index'),               genDefaults.monitorIndex, 0, 16,   1);
        const resWSpin     = this._createSpinRow(generatorGroup, _('Monitor Resolution Width'),   genDefaults.resW,         0, 10000, 1);
        const resHSpin     = this._createSpinRow(generatorGroup, _('Monitor Resolution Height'),  genDefaults.resH,         0, 10000, 1);
        const xSpin        = this._createSpinRow(generatorGroup, _('Start X Coordinate'),         genDefaults.startX,       0, 10000, 1);
        const ySpin        = this._createSpinRow(generatorGroup, _('Start Y Coordinate'),         genDefaults.startY,       0, 10000, 1);
        const numZonesSpin = this._createSpinRow(generatorGroup, _('Number of Zones'),            genDefaults.numZones,     1, 16,    1);

        const genRow = new Adw.ActionRow();
        const genBtn = new Gtk.Button({ label: _('Generate Zones'), halign: Gtk.Align.CENTER });
        genRow.set_child(genBtn);
        generatorGroup.add(genRow);        

        // Zones group
        const zonesGroup = new Adw.PreferencesGroup({ title: _('Zones'), description: _('Define rectangles for snapping and tabbing.') });
        page.add(zonesGroup);

        // Add New Zone header with button
        const addRow = new Adw.ActionRow({ title: _('Add New Zone'), subtitle: _('Insert a new zone with default values') });
        const addBtn = new Gtk.Button({ label: _('Add') });
        addBtn.connect('clicked', () => this._addZoneRow(null, zonesGroup));
        addRow.add_suffix(addBtn);
        addRow.activatable_widget = addBtn;
        zonesGroup.add(addRow);

        // Existing zones
        this._zoneRows = [];
        for (const z of cfg.zones) {
            this._addZoneRow(z, zonesGroup);
        }

        genBtn.connect('clicked', () => {
            const monitorIndex = monSpin.get_value_as_int();
            const resW = resWSpin.get_value_as_int();
            const resH = resHSpin.get_value_as_int();
            const startX = xSpin.get_value_as_int();
            const startY = ySpin.get_value_as_int();
            const numZones = numZonesSpin.get_value_as_int();

            // NEW: persist the latest generator inputs immediately
            cfg.zoneGenerator = {
                monitorIndex,
                resW,
                resH,
                startX,
                startY,
                numZones,
            };
            saveConfig(cfg);            

            // Remove existing zones for this monitor
            const rowsToRemove = this._zoneRows.filter(r => r.getZone().monitorIndex === monitorIndex);
            rowsToRemove.forEach(r => {
                zonesGroup.remove(r);
                const index = this._zoneRows.indexOf(r);
                if (index > -1) this._zoneRows.splice(index, 1);
            });

            // Calculate and add new zones
            const availableWidth = resW - startX;
            const zoneWidth = Math.floor(availableWidth / numZones);
            const zoneHeight = resH - startY;

            if (zoneWidth <= 0 || zoneHeight <= 0) {
                this._toast(window, _('Invalid dimensions. Check resolution and start coordinates.'));
                return;
            }

            for (let i = 0; i < numZones; i++) {
                const zoneData = {
                    name: `Monitor ${monitorIndex} Zone ${i + 1}`,
                    monitorIndex, x: startX + (i * zoneWidth), y: startY,
                    width: zoneWidth, height: zoneHeight,
                    gaps: { top: 8, right: 8, bottom: 8, left: 8 },
                    isPrimary: (i === 0),
                };
                this._addZoneRow(zoneData, zonesGroup);
            }
            this._toast(window, _(`Generated ${numZones} zones for monitor ${monitorIndex} (defaults saved).`));
        });

        // --- Tab Appearance Group ---
        const tabBarGroup = new Adw.PreferencesGroup({ title: _('Tab Appearance'), description: _('Configure the look and feel of tab bars and tabs.') });
        page.add(tabBarGroup);
        // Merge loaded config with defaults to prevent errors from missing keys
        const cfgTabBar = { ...defaultConfig().tabBar, ...(cfg.tabBar ?? {}) };

        // Height        
        const heightRow = new Adw.ActionRow({ title: _('Height (px)') });
        const heightAdj = new Gtk.Adjustment({ lower: 16, upper: 256, step_increment: 1, value: cfgTabBar.height ?? 32 });
        const heightSpin = new Gtk.SpinButton({ adjustment: heightAdj, digits: 0, halign: Gtk.Align.END });
        heightRow.add_suffix(heightSpin);
        heightRow.activatable_widget = heightSpin;
        tabBarGroup.add(heightRow);
        
        // Tab Bar Background Color (with opacity)
        const backgroundBtn = this._colorPickerRow({
            parentGroup: tabBarGroup,
            title: _('Tab Bar Background Color'),
            subtitle: _('Pick a color and opacity'),
            initial: cfgTabBar.backgroundColor ?? 'rgba(30,30,30,0.85)',
        });

        // Active Tab Background Color (with opacity)
        const activeBgBtn = this._colorPickerRow({
            parentGroup: tabBarGroup,
            title: _('Active Tab Background Color'),
            subtitle: _('Pick a color and opacity'),
            initial: cfgTabBar.activeBgColor ?? 'rgba(0,110,200,0.8)',
        });

        // Grouped Tabs Border Color (with opacity)
        const groupBorderBtn = this._colorPickerRow({
            parentGroup: tabBarGroup,
            title: _('Grouped Tabs Border Color'),
            subtitle: _('Pick a color and opacity'),
            initial: cfgTabBar.groupBorderColor ?? '#4A90E2',
        });

        // Corner Radius
        const radiusRow = new Adw.ActionRow({ title: _('Tab Corner Radius (px)') });
        const radiusAdj = new Gtk.Adjustment({ lower: 0, upper: 32, step_increment: 1, value: cfgTabBar.cornerRadius ?? 8 });
        const radiusSpin = new Gtk.SpinButton({ adjustment: radiusAdj, digits: 0, halign: Gtk.Align.END });
        radiusRow.add_suffix(radiusSpin);
        radiusRow.activatable_widget = radiusSpin;
        tabBarGroup.add(radiusRow);

        // Icon Size
        const iconSizeRow = new Adw.ActionRow({ title: _('Icon Size (px)') });
        const iconSizeAdj = new Gtk.Adjustment({ lower: 8, upper: 48, step_increment: 1, value: cfgTabBar.iconSize ?? 16 });
        const iconSizeSpin = new Gtk.SpinButton({ adjustment: iconSizeAdj, digits: 0, halign: Gtk.Align.END });
        iconSizeRow.add_suffix(iconSizeSpin);
        iconSizeRow.activatable_widget = iconSizeSpin;
        tabBarGroup.add(iconSizeRow);

        // Font Size
        const fontSizeRow = new Adw.ActionRow({ title: _('Font Size (pt)') });
        const fontSizeAdj = new Gtk.Adjustment({ lower: 6, upper: 24, step_increment: 1, value: cfgTabBar.fontSize ?? 10 });
        const fontSizeSpin = new Gtk.SpinButton({ adjustment: fontSizeAdj, digits: 0, halign: Gtk.Align.END });
        fontSizeRow.add_suffix(fontSizeSpin);
        fontSizeRow.activatable_widget = fontSizeSpin;
        tabBarGroup.add(fontSizeRow);

        // Spacing
        const spacingRow = new Adw.ActionRow({ title: _('Spacing between Tabs (px)') });
        const spacingAdj = new Gtk.Adjustment({ lower: 0, upper: 32, step_increment: 1, value: cfgTabBar.spacing ?? 4 });
        const spacingSpin = new Gtk.SpinButton({ adjustment: spacingAdj, digits: 0, halign: Gtk.Align.END });
        spacingRow.add_suffix(spacingSpin);
        spacingRow.activatable_widget = spacingSpin;
        tabBarGroup.add(spacingRow);

        // Max Width
        const maxWidthRow = new Adw.ActionRow({ title: _('Max Tab Width (px)') });
        const maxWidthAdj = new Gtk.Adjustment({ lower: 50, upper: 1000, step_increment: 10, value: cfgTabBar.maxWidth ?? 250 });
        const maxWidthSpin = new Gtk.SpinButton({ adjustment: maxWidthAdj, digits: 0, halign: Gtk.Align.END });
        maxWidthRow.add_suffix(maxWidthSpin);
        maxWidthRow.activatable_widget = maxWidthSpin;
        tabBarGroup.add(maxWidthRow);

        // Close Button Size
        const closeButtonSizeRow = new Adw.ActionRow({ title: _('Close Button Size (px)') });
        const closeButtonSizeAdj = new Gtk.Adjustment({ lower: 8, upper: 32, step_increment: 1, value: cfgTabBar.closeButtonSize ?? 12 });
        const closeButtonSizeSpin = new Gtk.SpinButton({ adjustment: closeButtonSizeAdj, digits: 0, halign: Gtk.Align.END });
        closeButtonSizeRow.add_suffix(closeButtonSizeSpin);
        closeButtonSizeRow.activatable_widget = closeButtonSizeSpin;
        tabBarGroup.add(closeButtonSizeRow);

        // --- Tab Behavior Group ---
        const behaviorGroup = new Adw.PreferencesGroup({ title: _('Tab Behavior'), description: _('Configure tab titles and grouping.') });
        page.add(behaviorGroup);

        // Title Source
        const titleSourceRow = new Adw.ActionRow({ title: _('Tab Title Source') });
        const titleModel = new Gtk.StringList();
        titleModel.append(_('Window Title'));
        titleModel.append(_('Application Name'));
        titleModel.append(_('WM_CLASS'));
        const titleDropdown = new Gtk.DropDown({ model: titleModel });
        const titleMap = { 'windowTitle': 0, 'appName': 1, 'wmClass': 2 };
        titleDropdown.set_selected(titleMap[cfgTabBar.titleSource] ?? 0);
        titleSourceRow.add_suffix(titleDropdown);
        titleSourceRow.activatable_widget = titleDropdown;
        behaviorGroup.add(titleSourceRow);

        // Grouping Criteria
        const groupSourceRow = new Adw.ActionRow({ title: _('Tab Grouping Criteria') });
        const groupModel = new Gtk.StringList();
        groupModel.append(_('Application Name'));
        groupModel.append(_('WM_CLASS'));
        const groupDropdown = new Gtk.DropDown({ model: groupModel });
        const groupMap = { 'appName': 0, 'wmClass': 1 };
        groupDropdown.set_selected(groupMap[cfgTabBar.groupingCriteria] ?? 0);
        groupSourceRow.add_suffix(groupDropdown);
        groupSourceRow.activatable_widget = groupDropdown;
        behaviorGroup.add(groupSourceRow);        

        // Sorting Criteria
        const sortSourceRow = new Adw.ActionRow({ title: _('Sorting Criteria') });
        const sortModel = new Gtk.StringList();
        sortModel.append(_('Window Title'));
        sortModel.append(_('Application Name'));
        sortModel.append(_('WM_CLASS'));
        const sortDropdown = new Gtk.DropDown({ model: sortModel });
        const sortMap = { 'windowTitle': 0, 'appName': 1, 'wmClass': 2 };
        sortDropdown.set_selected(sortMap[cfgTabBar.sortingCriteria] ?? 0);
        sortSourceRow.add_suffix(sortDropdown);
        sortSourceRow.activatable_widget = sortDropdown;
        behaviorGroup.add(sortSourceRow);

        // Sorting Order
        const sortOrderRow = new Adw.ActionRow({ title: _('Sorting Order') });
        const orderModel = new Gtk.StringList();
        orderModel.append(_('Ascending'));
        orderModel.append(_('Descending'));
        const orderDropdown = new Gtk.DropDown({ model: orderModel });
        const orderMap = { 'ASC': 0, 'DESC': 1 };
        orderDropdown.set_selected(orderMap[cfgTabBar.sortingOrder] ?? 0);
        sortOrderRow.add_suffix(orderDropdown);
        sortOrderRow.activatable_widget = orderDropdown;
        behaviorGroup.add(sortOrderRow);

        // Footer: Save & Apply (must be added to a PreferencesGroup, not directly to the Page)
        const footer = new Adw.ActionRow();

        const previewBtn = new Gtk.Button({ label: _('Preview Zones') });
        previewBtn.connect('clicked', () => {
            const zones = this._zoneRows.map(r => r.getZone());
            try {
                ensureConfigDir();
                const file = Gio.File.new_for_path(PREVIEW_PATH);
                const json = JSON.stringify(zones);
                file.replace_contents(
                    new TextEncoder().encode(json), null, false,
                    Gio.FileCreateFlags.REPLACE_DESTINATION, null
                );
                this._toast(window, _('Showing zone preview for 5 seconds.'));
            } catch (e) {
                log(`Error saving preview file: ${e}`);
                this._toast(window, _('Could not show preview.'));
            }
        });
        footer.add_prefix(previewBtn);
        const saveBtn = new Gtk.Button({ label: _('Save and Apply') });
        saveBtn.add_css_class('suggested-action');
        saveBtn.connect('clicked', () => {
            const newCfg = this._collectConfig(
                cfg, {
                    heightSpin, backgroundBtn, activeBgBtn, groupBorderBtn,
                    radiusSpin, closeButtonSizeSpin,
                    iconSizeSpin, fontSizeSpin, spacingSpin,
                    maxWidthSpin, titleDropdown, groupDropdown,
                    sortDropdown, orderDropdown
                }
            );
            if (saveConfig(newCfg)) {
                this._toast(window, _('Configuration saved.'));
            } else {
                this._toast(window, _('Failed to save configuration.'));
            }
        });
        footer.add_suffix(saveBtn);

        const actionsGroup = new Adw.PreferencesGroup({ title: _('Actions') });
        actionsGroup.add(footer);
        page.add(actionsGroup);
    }

    _addZoneRow(zoneOrNull, zonesGroup) {
        const initial = zoneOrNull ?? {
            name: '',
            monitorIndex: 0,
            x: 0, y: 0, width: 800, height: 600,
            gaps: { top: 8, right: 8, bottom: 8, left: 8 },
            isPrimary: false,
        };

        const row = new ZoneEditorRow(initial, (rowSelf) => {
            // remove from UI and local list
            zonesGroup.remove(rowSelf);
            this._zoneRows = this._zoneRows.filter(r => r !== rowSelf);
        });

        this._zoneRows.push(row);
        zonesGroup.add(row);
    }

    _collectConfig(existingCfg, widgets) {
        const zones = this._zoneRows.map(r => r.getZone());
        
        const titleMap = ['windowTitle', 'appName', 'wmClass'];
        const groupMap = ['appName', 'wmClass'];        
        const sortMap = ['windowTitle', 'appName', 'wmClass'];
        const orderMap = ['ASC', 'DESC'];

        const tabBar = {
            ...(existingCfg.tabBar ?? defaultConfig().tabBar),
            height: widgets.heightSpin.get_value_as_int(),
            backgroundColor: widgets.backgroundBtn.get_rgba().to_string(),
            activeBgColor: widgets.activeBgBtn.get_rgba().to_string(),
            groupBorderColor: widgets.groupBorderBtn.get_rgba().to_string(),
            cornerRadius: widgets.radiusSpin.get_value_as_int(),
            iconSize: widgets.iconSizeSpin.get_value_as_int(),
            fontSize: widgets.fontSizeSpin.get_value_as_int(),
            spacing: widgets.spacingSpin.get_value_as_int(),
            maxWidth: widgets.maxWidthSpin.get_value_as_int(),
            titleSource: titleMap[widgets.titleDropdown.get_selected()],
            groupingCriteria: groupMap[widgets.groupDropdown.get_selected()],
            closeButtonSize: widgets.closeButtonSizeSpin.get_value_as_int(),
            sortingCriteria: sortMap[widgets.sortDropdown.get_selected()],
            sortingOrder: orderMap[widgets.orderDropdown.get_selected()],
        };

        // Basic validation: drop zones with non-positive size
        const saneZones = zones.filter(z => (z.width > 0 && z.height > 0));

        // Preserve previously saved generator defaults
        const zoneGenerator = { ...(existingCfg.zoneGenerator ?? defaultConfig().zoneGenerator) };
        return { zones: saneZones, tabBar, zoneGenerator };
    }

    _toast(window, text) {
        // If running inside gnome-extensions-app, we can pop a simple banner using Adw.ToastOverlay if present.
        // Fall back to console.
        try {
            if (!this._overlay) {
                this._overlay = new Adw.ToastOverlay();
                // Wrap current content
                const child = window.get_content();
                window.set_content(this._overlay);
                if (child)
                    this._overlay.set_child(child);
            }
            const toast = new Adw.Toast({ title: text, timeout: 3 });
            this._overlay.add_toast(toast);
        } catch (e) {
            log(`${text} (no toast overlay available)`);
        }
    }
}




===== FILE: ./modules/Tab.js =====
// modules/Tab.js
import St from 'gi://St';
import GObject from 'gi://GObject';
import Pango from 'gi://Pango';
import Clutter from 'gi://Clutter';

export const Tab = GObject.registerClass({
    GTypeName: 'TabbedTiling_Tab',
    Signals: {
        'close-clicked': {},
    },
}, class Tab extends St.Button {
    _init(window, app, config) {
        super._init({
            style_class: 'zone-tab',
            can_focus: true,
            reactive: true,
        });

        this.window = window;
        this.app = app;
        this._config = config; // Save config        

        const box = new St.BoxLayout({
            style_class: 'zone-tab-content',
            x_expand: true,
        });
        this.set_child(box);

        // App Icon
        if (app) {
            const icon = new St.Icon({
                gicon: app.get_icon(),
                style_class: 'zone-tab-app-icon',
                icon_size: this._config.iconSize ?? 16,                
            });
            box.add_child(icon);
        }

        // Title Label
        const label = new St.Label({
            text: this.getTabTitle(),
            y_align: Clutter.ActorAlign.CENTER,
            style_class: 'zone-tab-label',
        });
        // Apply font size from config
        label.style = `font-size: ${this._config.fontSize ?? 10}pt;`;        
        label.clutter_text.set_ellipsize(Pango.EllipsizeMode.END);
        box.add_child(label);

        // Spacer to push the close button to the right
        const spacer = new St.Bin({ x_expand: true });
        box.add_child(spacer);

        // Close Button
        const closeButton = new St.Button({ style_class: 'zone-tab-close-button' });
        closeButton.set_child(new St.Icon({
            icon_name: 'window-close-symbolic',
            icon_size: this._config.closeButtonSize ?? 12,
        }));
        closeButton.connect('clicked', () => this.emit('close-clicked'));
        box.add_child(closeButton);

        // Connect to window title changes to update the tab
        this._titleChangedId = window.connect('notify::title', () => {
            label.set_text(this.getTabTitle());
        });
    }

    getTabTitle() {
        const source = this._config.titleSource ?? 'windowTitle';
        if (source === 'appName' && this.app) return this.app.get_name();
        if (source === 'wmClass') return this.window.get_wm_class();

        // Default to window title with fallbacks
        return this.window.get_title() || (this.app ? this.app.get_name() : null) || this.window.get_wm_class() || 'Untitled';
    }

    getGroupingId() {
        const criteria = this._config.groupingCriteria ?? 'appName';
        if (criteria === 'wmClass') return this.window.get_wm_class();
        // Default to app name
        return this.app ? this.app.get_id() : (this.window.get_wm_class() || 'unknown');
    }

    getSortKey() {
        const criteria = this._config.sortingCriteria ?? 'windowTitle';
        if (criteria === 'appName' && this.app) return this.app.get_name();
        if (criteria === 'wmClass') return this.window.get_wm_class();

        // Default to window title with fallbacks
        return this.window.get_title() || (this.app ? this.app.get_name() : null) || this.window.get_wm_class() || 'Untitled';
    }

    getGroupSortKey() {
        const criteria = this._config.groupingCriteria ?? 'appName';
        if (criteria === 'wmClass') return this.window.get_wm_class() || 'unknown';
        // Default to app name, using the *display name* for sorting
        return this.app ? this.app.get_name() : (this.window.get_wm_class() || 'unknown');
    }

    destroy() {
        if (this._titleChangedId && this.window) {
            try {
                this.window.disconnect(this._titleChangedId);
            } catch (e) { /* ignore */ }
        }
        super.destroy();
    }
});



===== FILE: ./modules/ConfigManager.js =====
// modules/ConfigManager.js
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';

const log = msg => console.log(`[TabbedTiling.ConfigManager] ${msg}`);
const CONFIG_DIR = 'tabbedtiling';
const CONFIG_FILENAME = 'config.json';
const PREVIEW_FILENAME = 'preview.json';

export class ConfigManager {
    constructor() {
        this._configDir = Gio.File.new_for_path(GLib.get_user_config_dir()).get_child(CONFIG_DIR);
        this._configFile = this._configDir.get_child(CONFIG_FILENAME);
        this._previewFile = this._configDir.get_child(PREVIEW_FILENAME);
        this._config = null;

        this._ensureDirExists();
    }

    _ensureDirExists() {
        if (!this._configDir.query_exists(null)) {
            log('Config directory not found, creating it.');
            try {
                this._configDir.make_directory_with_parents(null);
            } catch (e) {
                log(`Error creating config directory: ${e}`);
            }
        }
    }
    
    _getDefaultConfig() {
        return {
            zones: [],
            tabBar: {
                height: 32,
                backgroundColor: 'rgba(30, 30, 30, 0.85)',
                // NEW: user-tunable colors
                activeBgColor: 'rgba(0, 110, 200, 0.8)',
                groupBorderColor: '#4A90E2',
                cornerRadius: 8,
                iconSize: 16,
            fontSize: 10, // in points (pt)
            spacing: 4, // between tabs
            maxWidth: 250, // max width of a single tab
            titleSource: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            groupingCriteria: 'appName', // 'appName', 'wmClass'
            closeButtonSize: 12,
            sortingCriteria: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            sortingOrder: 'ASC', // 'ASC', 'DESC'            
            },
            // NEW: persisted defaults for the Zone Generator UI
            zoneGenerator: {
                monitorIndex: 0,
                resW: 1920,
                resH: 1080,
                startX: 0,
                startY: 0,
                numZones: 2,
            },
        };
    }

    getConfigFile() {
        return this._configFile;
    }

    getPreviewFile() {
        return this._previewFile;
    }

    load() {
        if (!this._configFile.query_exists(null)) {
            log('Config file not found, creating a default one.');
            this._config = this._getDefaultConfig();
            this.save(this._config);
        } else {
            try {
                const [ok, contents] = this._configFile.load_contents(null);
                if (ok) {
                    this._config = JSON.parse(new TextDecoder().decode(contents));
                } else {
                    throw new Error("Failed to load file contents.");
                }
            } catch (e) {
                log(`Error reading or parsing config file: ${e}. Using default config.`);
                this._config = this._getDefaultConfig();
            }
        }
        return this._config;
    }

    getConfig() {
        return this._config || this.load();
    }

    save(configObject) {
        try {
            const data = JSON.stringify(configObject, null, 2);
            this._configFile.replace_contents(
                data,
                null,
                false,
                Gio.FileCreateFlags.REPLACE_DESTINATION,
                null
            );
            this._config = configObject;
            log('Configuration saved successfully.');
        } catch (e) {
            log(`Error saving configuration: ${e}`);
        }
    }

    savePreviewZones(zones) {
        try {
            const data = JSON.stringify(zones);
            this._previewFile.replace_contents(
                data, null, false,
                Gio.FileCreateFlags.REPLACE_DESTINATION, null
            );
        } catch (e) {
            log(`Error saving preview file: ${e}`);
        }
    }

    loadPreviewZones() {
        try {
            const [ok, contents] = this._previewFile.load_contents(null);
            if (ok) {
                return JSON.parse(new TextDecoder().decode(contents));
            }
        } catch (e) {
            log(`Error loading preview file: ${e}`);
        }
        return null;
    }
}



===== FILE: ./modules/TabBar.js =====
// modules/TabBar.js
import St from 'gi://St';
import GObject from 'gi://GObject';
import Clutter from 'gi://Clutter';
import Shell from 'gi://Shell';
import GLib from 'gi://GLib';

import { Tab } from './Tab.js';

const log = msg => console.log(`[TabbedTiling.TabBar] ${msg}`);

export const TabBar = GObject.registerClass({
    GTypeName: 'TabbedTiling_TabBar',
    Signals: {
        'tab-clicked': { param_types: [GObject.TYPE_OBJECT] }, // Meta.Window
        'tab-removed': { param_types: [GObject.TYPE_OBJECT] }, // Meta.Window
        'tab-moved':   { param_types: [GObject.TYPE_OBJECT] }, // Custom object
    },
}, class TabBar extends St.BoxLayout {
    _init(tabBarConfig) {
        super._init({
            style_class: 'zone-tab-bar',
            reactive: true,
            visible: false,
        });
        
        this.set_height(tabBarConfig.height || 32);
        this.style = `background-color: ${tabBarConfig.backgroundColor};`;
        this._config = tabBarConfig;
        this._tabs = new Map();
        this._windowTracker = Shell.WindowTracker.get_default();

        // Settings-driven colors (with sensible fallbacks)
        this._activeBgColor = String(this._config.activeBgColor ?? 'rgba(0, 110, 200, 0.8)');
        this._groupBorderColor = String(this._config.groupBorderColor ?? '#4A90E2');

        this._tabContainer = new St.BoxLayout({
            style_class: 'zone-tab-container',
            style: `spacing: ${this._config.spacing ?? 4}px;`
        });
        this.add_child(this._tabContainer);        
    }

    /* ---------- tiny helpers to compose inline styles without clobbering ---------- */

    _ensureStyleSlots(tab) {
        // Keep separate parts and join them so set_style never overwrites others
        if (!tab.__ttStyleParts) {
            tab.__ttStyleParts = {
                radius: '',     // e.g., 'border-radius: 8px 8px 0 0;'
                bg: '',         // e.g., 'background-color: rgba(...);'
                border: '',     // e.g., 'border-color: #4A90E2;'
            };
        }
        return tab.__ttStyleParts;
    }

    _applyInlineStyle(tab) {
        const p = this._ensureStyleSlots(tab);
        tab.set_style(`${p.radius}${p.bg}${p.border}`);
    }

    _setRadius(tab, css) {
        const p = this._ensureStyleSlots(tab);
        p.radius = css ? `border-radius: ${css};` : '';
        this._applyInlineStyle(tab);
    }

    _setBg(tab, css) {
        const p = this._ensureStyleSlots(tab);
        p.bg = css ? `background-color: ${css};` : '';
        this._applyInlineStyle(tab);
    }

    _setBorderColor(tab, css) {
        const p = this._ensureStyleSlots(tab);
        p.border = css ? `border-color: ${css};` : '';
        this._applyInlineStyle(tab);
    }

    /* ----------------------------------------------------------------------------- */

    addTab(window) {
        if (this._tabs.has(window)) {
            this.setActiveTab(window);
            return;
        }

        const app = this._windowTracker.get_window_app(window);
        const tab = new Tab(window, app, this._config);
        
        tab.connect('close-clicked', () => this.emit('tab-removed', window));
        tab.connect('button-press-event', (_actor, _event) => {
            try {
                this.emit('tab-clicked', window);
            } catch (e) {
                logError(e, 'Emitting tab-clicked failed');
            }
            return Clutter.EVENT_STOP;
        });

        this._tabs.set(window, tab);
        this._tabContainer.add_child(tab);

        this.reorderTabs();
    }

    removeTab(window) {
        if (this._tabs.has(window)) {
            const tab = this._tabs.get(window);
            this._tabContainer.remove_child(tab);
            tab.destroy();
            this._tabs.delete(window);
            this.reorderTabs();
        }
    }
    
    setActiveTab(window) {
        for (const [win, tab] of this._tabs.entries()) {
            if (win === window) {
                tab.add_style_class_name('active');
                // settings-defined active bg
                this._setBg(tab, this._activeBgColor);
            } else {
                tab.remove_style_class_name('active');
                // clear bg override; fall back to CSS default
                this._setBg(tab, '');
            }
        }
    }

    reorderTabs(zoneName = 'Unknown') {
        const tabs = this._tabContainer.get_children();

        if (tabs.length < 2) {
            this._updateGroupStyles();
            return;
        }

        const sortOrder = (this._config.sortingOrder === 'DESC') ? -1 : 1;

        tabs.sort((a, b) => {
            const groupA = a.getGroupSortKey()?.toLowerCase() ?? '';
            const groupB = b.getGroupSortKey()?.toLowerCase() ?? '';

            if (groupA < groupB) return -1 * sortOrder;
            if (groupA > groupB) return 1 * sortOrder;

            const keyA = a.getSortKey()?.toLowerCase() ?? '';
            const keyB = b.getSortKey()?.toLowerCase() ?? '';

            let result = 0;
            if (keyA < keyB) result = -1;
            if (keyA > keyB) result = 1;

            return result * sortOrder;
        });

        tabs.forEach((tab, index) => {
            this._tabContainer.set_child_at_index(tab, index);
        });

        this._updateGroupStyles();
        this._updateTabSizes();
    }

    getTabs() {
        return this._tabContainer.get_children();
    }

    _updateTabSizes() {
        const children = this._tabContainer.get_children();
        if (children.length === 0) return;

        const availableWidth = this.get_width();
        const maxWidth = this._config.maxWidth ?? 250;

        const widestPreferred = children.reduce((max, c) => {
            return Math.max(max, c.get_preferred_width(-1)[1]);
        }, 0);

        const idealWidth = Math.min(widestPreferred, maxWidth);

        if (idealWidth * children.length > availableWidth) {
            const newWidth = Math.floor(availableWidth / children.length);
            children.forEach(c => c.set_width(newWidth));
        } else {
            children.forEach(c => c.set_width(idealWidth));
        }
    }

    _updateGroupStyles() {
        const children = this._tabContainer.get_children();
        const baseR = Number(this._config.cornerRadius ?? 8);

        if (children.length <= 1) {
            children.forEach(c => {
                c.remove_style_class_name('grouped-start');
                c.remove_style_class_name('grouped-middle');
                c.remove_style_class_name('grouped-end');
                // (1) Single tab → both corners rounded
                this._setRadius(c, `${baseR}px ${baseR}px 0 0`);
                // Not grouped → default border color from CSS, so clear any inline
                this._setBorderColor(c, '');
            });
            return;
        }

        for (let i = 0; i < children.length; i++) {
            const currentTab = children[i];
            const prevTab = children[i - 1] ?? null;
            const nextTab = children[i + 1] ?? null;

            const currentId = currentTab.getGroupingId();
            const prevId = prevTab ? prevTab.getGroupingId() : null;
            const nextId = nextTab ? nextTab.getGroupingId() : null;

            currentTab.remove_style_class_name('grouped-start');
            currentTab.remove_style_class_name('grouped-middle');
            currentTab.remove_style_class_name('grouped-end');

            // Default (solo) → both rounded + default border
            let radiusCss = `${baseR}px ${baseR}px 0 0`;
            let borderColorCss = '';

            if (currentId && currentId === nextId && currentId !== prevId) {
                currentTab.add_style_class_name('grouped-start');
                // (2)(3) First in group → only top-left
                radiusCss = `${baseR}px 0 0 0`;
                borderColorCss = this._groupBorderColor;
            } else if (currentId && currentId === prevId && currentId === nextId) {
                currentTab.add_style_class_name('grouped-middle');
                // (6) Middle in group → no radii
                radiusCss = `0`;
                borderColorCss = this._groupBorderColor;
            } else if (currentId && currentId === prevId && currentId !== nextId) {
                currentTab.add_style_class_name('grouped-end');
                // (4)(5) Last in group → only top-right
                radiusCss = `0 ${baseR}px 0 0`;
                borderColorCss = this._groupBorderColor;
            }

            this._setRadius(currentTab, radiusCss);
            this._setBorderColor(currentTab, borderColorCss);
        }
    }

    destroy() {
        this._tabs.forEach(tab => tab.destroy());
        this._tabs.clear();
        super.destroy();
    }
});




===== FILE: ./modules/Highlighter.js =====
// modules/Highlighter.js
import St from 'gi://St';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import GLib from 'gi://GLib';
import Clutter from 'gi://Clutter';

const PREVIEW_TIMEOUT_MS = 5000; // 5 seconds

export class Highlighter {
    constructor() {
        this._hoverHighlight = null;
        this._previewHighlights = [];
        this._previewTimeoutId = 0;
    }

    _createHighlightActor(styleClass) {
        const actor = new St.Bin({
            style_class: styleClass,
            reactive: false,
            can_focus: false,
            x_expand: true,
            y_expand: true,
        });
        Main.layoutManager.addChrome(actor, { affectsStruts: false });
        actor.set_offscreen_redirect(Clutter.OffscreenRedirect.ALWAYS);
        return actor;
    }

    showHoverHighlight(zone) {
        if (!this._hoverHighlight) {
            this._hoverHighlight = this._createHighlightActor('zone-highlight');
        }

        const monitor = Main.layoutManager.monitors[zone.monitorIndex];
        if (!monitor) return;

        this._hoverHighlight.set_position(monitor.x + zone.x, monitor.y + zone.y);
        this._hoverHighlight.set_size(zone.width, zone.height);
        this._hoverHighlight.show();
    }

    hideHoverHighlight() {
        if (this._hoverHighlight) {
            this._hoverHighlight.hide();
        }
    }

    showAllPreviews(zones) {
        this.destroyPreviews(); // Clear any existing previews

        if (this._previewTimeoutId) {
            GLib.Source.remove(this._previewTimeoutId);
        }

        zones.forEach(zone => {
            const monitor = Main.layoutManager.monitors[zone.monitorIndex];
            if (!monitor) return;

            const actor = this._createHighlightActor('zone-highlight');
            actor.set_position(monitor.x + zone.x, monitor.y + zone.y);
            actor.set_size(zone.width, zone.height);
            actor.show();
            this._previewHighlights.push(actor);
        });

        // Previews automatically hide after a timeout
        this._previewTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, PREVIEW_TIMEOUT_MS, () => {
            this.destroyPreviews();
            this._previewTimeoutId = 0;
            return GLib.SOURCE_REMOVE;
        });
    }

    destroyPreviews() {
        this._previewHighlights.forEach(actor => actor.destroy());
        this._previewHighlights = [];
        if (this._previewTimeoutId) {
            GLib.Source.remove(this._previewTimeoutId);
            this._previewTimeoutId = 0;
        }        
    }

    destroy() {
        if (this._hoverHighlight) {
            this._hoverHighlight.destroy();
            this._hoverHighlight = null;
        }
        this.destroyPreviews();
    }
}



===== FILE: ./modules/WindowManager.js =====
// modules/WindowManager.js
import Meta from 'gi://Meta';
import Shell from 'gi://Shell';
import GLib from 'gi://GLib';
import Gio from 'gi://Gio';
import Mtk from 'gi://Mtk';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Clutter from 'gi://Clutter';

import { Zone } from './Zone.js';

const log = (msg) => console.log(`[TabbedTiling.WindowManager] ${msg}`);

export class WindowManager {
    constructor(configManager, highlighter) {
        this._configManager = configManager;
        this._highlighter = highlighter;
        this._zones = [];
        this._signalConnections = [];
        this._windowTracker = Shell.WindowTracker.get_default();
        // Track per-window state change handlers so we can disconnect safely
        this._windowStateHandlers = new Map(); // Meta.Window -> { ids: number[] }        
        this._windowStateSignals = new Map();        
        this._loginProxy = null;
        // Hover polling while dragging (since MetaDisplay lacks grab-op-motion)
        this._dragHoverTimerId = 0;        
    }

    enable() {
        log("DEBUG: enable() called.");
        this.reloadConfiguration();
        this._connectSignals();
        this._updateAllZonesVisibility();        
        this._snapExistingWindows();
    }

    disable() {
        log("DEBUG: disable() called.");
        this._disconnectSignals();
        this._zones.forEach(zone => zone.destroy());
        this._zones = [];
        this._highlighter.hideHoverHighlight();
    }

    reloadConfiguration() {
        log("DEBUG: reloadConfiguration() called.");
        const config = this._configManager.load();

        this._zones.forEach(zone => zone.destroy());
        this._zones = [];

        config.zones.forEach(zoneData => {
            this._zones.push(new Zone(zoneData, config.tabBar, this._windowTracker));
        });

        log(`Loaded ${this._zones.length} zones.`);
        this._updateAllZonesVisibility();        
        this._snapExistingWindows();
    }

    _connectSignals() {
        log("DEBUG: _connectSignals() called.");
        const connect = (gobj, name, cb) => {
            const id = gobj.connect(name, cb);
            this._signalConnections.push({ gobj, id });
        };

        connect(global.display, 'grab-op-begin', this._onGrabOpBegin.bind(this));
        connect(global.display, 'grab-op-end', this._onGrabOpEnd.bind(this));
        connect(global.display, 'window-created', this._onWindowCreated.bind(this));
        connect(this._windowTracker, 'tracked-windows-changed', this._onTrackedWindowsChanged.bind(this));
        connect(Main.layoutManager, 'monitors-changed', () => this.reloadConfiguration());

        // Manually create a proxy for LoginManager to handle suspend/resume.
        const LoginManagerIface = `
        <node>
            <interface name="org.freedesktop.login1.Manager">
                <signal name="PrepareForSleep">
                    <arg type="b" name="starting"/>
                </signal>
            </interface>
        </node>`;

        log("DEBUG: Attempting to create LoginManager proxy...");
        try {
            const info = Gio.DBusNodeInfo.new_for_xml(LoginManagerIface);
            const interfaceInfo = info.interfaces.find(i => i.name === 'org.freedesktop.login1.Manager');

            Gio.DBusProxy.new_for_bus(
                Gio.BusType.SYSTEM,
                Gio.DBusProxyFlags.NONE,
                interfaceInfo,
                'org.freedesktop.login1',      // name
                '/org/freedesktop/login1',      // object path
                'org.freedesktop.login1.Manager', // interface name
                null, // cancellable
                (source_object, res) => {
                    try {
                        const proxy = Gio.DBusProxy.new_for_bus_finish(res);
                        log("DEBUG: LoginManager proxy created successfully.");
                        this._loginProxy = proxy;

                        connect(this._loginProxy, 'g-signal', (p, sender, signal, params) => {
                             if (signal === 'PrepareForSleep') {
                                const starting = params.get_child_value(0).get_boolean();
                                if (!starting) {
                                    log("DEBUG: System resumed from sleep, re-snapping windows.");
                                    GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1000, () => {
                                        this._snapExistingWindows();
                                        return GLib.SOURCE_REMOVE;
                                    });
                                }
                             }
                        });
                    } catch (e) {
                        log(`ERROR: Failed to finalize LoginManager proxy or connect signal. Error: ${e.message}`);
                    }
                }
            );
        } catch (e) {
            log(`ERROR: Could not create LoginManager proxy. D-Bus XML may be invalid. Error: ${e.message}`);
        }
    }

    _disconnectSignals() {
        log("DEBUG: _disconnectSignals() called.");
        this._signalConnections.forEach(({ gobj, id }) => {
            try {
                gobj.disconnect(id);
            } catch (e) {
                // Ignore errors if object is already gone
            }
        });
        this._signalConnections = [];
        this._loginProxy = null;
        this._disconnectWindowStateSignals();
        this._stopDragHoverTimer();        
    }

    _trackWindowState(window) {
        if (!window || this._windowStateSignals.has(window)) {
            return;
        }

        const onStateChanged = () => {
            // get_maximized() is a bitmask; consider "normal" when it's NONE and not fullscreen.
            const maxFlags = (typeof window.get_maximized === 'function') ? window.get_maximized() : Meta.MaximizeFlags.NONE;
            const isFs     = (typeof window.is_fullscreen === 'function') ? window.is_fullscreen() : false;
            
            if (maxFlags === Meta.MaximizeFlags.NONE && !isFs) {
                const zone = this._findZoneForWindow(window);
                if (zone) {
                    zone.snapWindow(window);
                }
            }
            // Always update tab bar visibilities (snapped windows only).
            this._updateAllZonesVisibility();
        };

        const ids = [];
        try { ids.push(window.connect('notify::maximized', onStateChanged)); } catch (_) {}
        // X11 (MetaWindowX11) does NOT have 'fullscreen-changed'; rely on property notify
        try { ids.push(window.connect('notify::fullscreen', onStateChanged)); } catch (_) {}
        this._windowStateSignals.set(window, ids);
    }

    _untrackWindowState(window) {
        if (this._windowStateSignals.has(window)) {
            this._windowStateSignals.get(window).forEach(id => window.disconnect(id));
            this._windowStateSignals.delete(window);
        }
    }

    _disconnectWindowStateSignals() {
        this._windowStateSignals.forEach((ids, window) => {
            ids.forEach(id => {
                try { window.disconnect(id); } catch (e) { /* ignore */ }
            });
        });
        this._windowStateSignals.clear();        
    }

    _startDragHoverTimer() {
        if (this._dragHoverTimerId) return;
        // ~60fps polling (about 16ms). Cheap and reliable on both X11/Wayland.
        this._dragHoverTimerId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, 16, () => {
            this._updateHoverHighlightFromPointer();
            return GLib.SOURCE_CONTINUE;
        });
    }

    _stopDragHoverTimer() {
        if (this._dragHoverTimerId) {
            GLib.Source.remove(this._dragHoverTimerId);
            this._dragHoverTimerId = 0;
        }
        this._highlighter.hideHoverHighlight();
    }

    _updateHoverHighlightFromPointer() {
        const [x, y, mods] = global.get_pointer();
        // If Ctrl is held, or we don't currently have a snappable drag, hide highlight.
        if ((mods & Clutter.ModifierType.CONTROL_MASK) !== 0) {
            this._highlighter.hideHoverHighlight();
            return;
        }
        const zone = this._findZoneAt(x, y) ?? this._findNearestZoneWithinThreshold(x, y, 48);
        if (zone) this._highlighter.showHoverHighlight(zone);
        else this._highlighter.hideHoverHighlight();
    }

	 _watchWindowState(window) {
        if (!window || this._windowStateHandlers.has(window))
            return;

        const ids = [];
        // Maximize changes (property is a bitmask)
        try { ids.push(window.connect('notify::maximized', () => this._onWindowStateChanged(window))); } catch (_) {}
        // Use property notification for fullscreen on both Wayland and X11.
        try { ids.push(window.connect('notify::fullscreen', () => this._onWindowStateChanged(window))); } catch (_) {}
        // Cleanup when window goes away
        ids.push(window.connect('unmanaged', () => this._unwatchWindowState(window)));

        this._windowStateHandlers.set(window, { ids });
    }

    _unwatchWindowState(window) {
        const entry = this._windowStateHandlers.get(window);
        if (!entry) return;
        for (const id of entry.ids) {
            try { window.disconnect(id); } catch (_) {}
        }
        this._windowStateHandlers.delete(window);
        // Recompute visibility in case this was the last maximized on its monitor
        this._recomputeMonitorTabBars(window?.get_monitor?.());
    }

    _onWindowStateChanged(window) {
        this._recomputeMonitorTabBars(window ? window.get_monitor() : -1);
    }

    _isSnappable(window) {
        if (!window || window.is_fullscreen()) return false;
        const type = window.get_window_type();
        return type === Meta.WindowType.NORMAL;
    }

    _onGrabOpBegin(display, window, op) {
        if (!this._isSnappable(window)) return;

        // Bypass tiling logic if holding CTRL
        const [, , mods] = global.get_pointer();
        if ((mods & Clutter.ModifierType.CONTROL_MASK) !== 0) {
            window._tilingBypass = true;
            // Ensure any hover highlight is hidden while bypassing
            this._highlighter.hideHoverHighlight();        
            this._highlighter.hideHoverHighlight();
            this._stopDragHoverTimer();                
            return;
        }
        delete window._tilingBypass; // Clear it if CTRL isn't held

        // ONLY apply moving logic for MOVING ops. For RESIZING, we do nothing.
        if (op === Meta.GrabOp.MOVING) {
            const currentZone = this._findZoneForWindow(window);
            if (currentZone) {
                window.raise();
                window._tilingOriginalZone = currentZone;
            }
            // Begin hover polling for live zone highlight
            this._startDragHoverTimer();            
        } else {
            // For any other operation (like resizing), set the bypass flag.
            // This prevents _onGrabOpEnd from trying to re-snap the window.
            window._tilingBypass = true;
            this._stopDragHoverTimer();            
        }
    }

    _distancePointToRect(x, y, rect) {
        // rect: {x, y, width, height}
        const rx1 = rect.x;
        const ry1 = rect.y;
        const rx2 = rect.x + rect.width;
        const ry2 = rect.y + rect.height;

        // dx/dy are zero if the point is inside the interval
        const dx = (x < rx1) ? (rx1 - x) : (x > rx2) ? (x - rx2) : 0;
        const dy = (y < ry1) ? (ry1 - y) : (y > ry2) ? (y - ry2) : 0;
        // Euclidean distance to the rectangle (0 if inside)
        return Math.hypot(dx, dy);
    }

    _findNearestZoneWithinThreshold(x, y, thresholdPx = 48) {
        // Find the closest zone (by rect distance) on the pointer's monitor,
        // accepting it if the pointer is within `thresholdPx` of the zone.
        const monitorIndex = global.display.get_monitor_index_for_rect(
            new Mtk.Rectangle({ x, y, width: 1, height: 1 })
        );
        const monitor = Main.layoutManager.monitors[monitorIndex];
        if (!monitor) return null;

        let best = { zone: null, dist: Infinity };
        for (const zone of this._zones) {
            if (zone.monitorIndex !== monitorIndex) continue;
            const rect = {
                x: monitor.x + zone.x,
                y: monitor.y + zone.y,
                width: zone.width,
                height: zone.height,
            };
            const d = this._distancePointToRect(x, y, rect);
            if (d < best.dist) {
                best = { zone, dist: d };
            }
        }
        return (best.zone && best.dist <= thresholdPx) ? best.zone : null;
    }

    _onGrabOpEnd(display, window) {
        if (window._tilingBypass) {
            delete window._tilingBypass;
            this._highlighter.hideHoverHighlight();
            return;
        }

        if (!this._isSnappable(window)) return;
        this._stopDragHoverTimer();
        this._highlighter.hideHoverHighlight();

        const [pointerX, pointerY] = global.get_pointer();
        // 1) Try direct hit
        let targetZone = this._findZoneAt(pointerX, pointerY);

        const originalZone = window._tilingOriginalZone;
        if (originalZone) {
            delete window._tilingOriginalZone;
        }

        // If we dragged out of all zones (e.g., to the very top pixel),
        // 2) Try nearest zone within a small threshold
        if (!targetZone) {
            targetZone = this._findNearestZoneWithinThreshold(pointerX, pointerY, 48);
        }

        // 3) If still nothing, and we had an original zone on the same monitor,
        //    snap back to the original zone (graceful fallback).
        if (!targetZone && originalZone) {
            const monitorAtDrop = global.display.get_monitor_index_for_rect(
                new Mtk.Rectangle({ x: pointerX, y: pointerY, width: 1, height: 1 })
            );
            if (monitorAtDrop === originalZone.monitorIndex) {
                targetZone = originalZone;
            }
        }

        if (originalZone && targetZone && targetZone !== originalZone) {
            originalZone.unsnapWindow(window);
        }

        if (targetZone) {
            targetZone.snapWindow(window);
        }
    }

    _onWindowCreated(display, window) {
        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 200, () => {
            if (!window || !this._isSnappable(window)) return GLib.SOURCE_REMOVE;
            this._trackWindowState(window); // Track state changes (maximized, etc.)
            const monitorIndex = window.get_monitor();
            // Track state so we can hide tab bars when this snapped window goes max/fullscreen
            this._watchWindowState(window);            
            const primaryZone = this._zones.find(z =>
                z.monitorIndex === monitorIndex && z.isPrimary
            );

            if (primaryZone) {
                log(`New window "${window.get_title()}" snapping to primary zone.`);
                primaryZone.snapWindow(window);
            }
            return GLib.SOURCE_REMOVE;
        });
    }

    // Re-run per monitor when tracked windows list changes (e.g., window closed)
    _onTrackedWindowsChanged() {
        const currentWindows = new Set(global.get_window_actors().map(a => a.get_meta_window()));
        const previouslyTracked = new Set(this._windowStateSignals.keys());

        // Untrack closed windows and remove them from zones
        for (const window of previouslyTracked) {
            if (!currentWindows.has(window)) {
                this._untrackWindowState(window);
                const zone = this._findZoneForWindow(window);
                if (zone) {
                    log(`Window "${window.get_title()}" is no longer tracked, removing from zone "${zone.name}".`);
                    zone.unsnapWindow(window);
                    this._unwatchWindowState(window);                    
                }
            }
        // Recompute once after processing removals
        this._recomputeAllMonitors();
        }

        // Track new windows
        for (const window of currentWindows) {
            if (!previouslyTracked.has(window)) {
                this._trackWindowState(window);
            }
        }
        this._updateAllZonesVisibility();
    }

    _updateAllZonesVisibility() {
        // Hide tab bars per monitor only if any **snapped** window there is max/fullscreen.
        const monitors = Main.layoutManager.monitors || [];
        for (let i = 0; i < monitors.length; i++) {
            const shouldHide = this._anySnappedWindowMaxOrFsOnMonitor(i);
            // Use the Zone force-hide path so bar state is consistent everywhere.
            for (const zone of this._zones) {
                if (zone.monitorIndex === i)
                    zone.setForceHidden(shouldHide);
            }
        }
    }

    _snapExistingWindows() {
        log("DEBUG: _snapExistingWindows() called.");
        const allWindows = global.get_window_actors().map(a => a.get_meta_window());
        allWindows.forEach(window => {
            this._trackWindowState(window);        
            if (this._isSnappable(window)) {
                let targetZone = this._findZoneForWindow(window);

                if (!targetZone) {
                    targetZone = this._findBestZoneForWindow(window);
                }

                if (targetZone) {
                    targetZone.snapWindow(window);
                    this._watchWindowState(window);                    
                }
            }
        });
        this._updateAllZonesVisibility();        
        this._zones.forEach(zone => zone.reorderTabs());
        this._logZoneStates();
    }

    _anySnappedWindowMaxOrFsOnMonitor(monitorIndex) {
        for (const zone of this._zones) {
            if (zone.monitorIndex !== monitorIndex) continue;
            const snapped = zone.getSnappedWindows();
            for (const w of snapped) {
                try {
                    const isOnMon = (w.get_monitor && w.get_monitor() === monitorIndex);
                    if (!isOnMon) continue;
                    const isFs = (typeof w.is_fullscreen === 'function') ? w.is_fullscreen() : false;
                    const isMax = (typeof w.get_maximized === 'function') ? !!w.get_maximized() : false;
                    if (isFs || isMax)
                        return true;
                } catch (_) {}
            }
        }
        return false;
    }

    _setTabBarsOnMonitorVisible(monitorIndex, visible) {
        for (const zone of this._zones) {
            if (zone.monitorIndex === monitorIndex) {
                zone.setTabBarVisible(visible);
            }
        }
    }

    _recomputeMonitorTabBars(monitorIndex) {
        if (monitorIndex == null || monitorIndex < 0) return;
        const shouldHide = this._anySnappedWindowMaxOrFsOnMonitor(monitorIndex);
        // Keep logic consistent with _updateAllZonesVisibility()
        for (const zone of this._zones)
            if (zone.monitorIndex === monitorIndex)
                zone.setForceHidden(shouldHide);
    }

    _recomputeAllMonitors() {
        const monitors = Main.layoutManager.monitors || [];
        for (let i = 0; i < monitors.length; i++)
            this._recomputeMonitorTabBars(i);
    }

    _logZoneStates() {
        log('--- Final Zone States ---');
        this._zones.forEach(zone => {
            const tabs = zone.getTabs();
            if (tabs.length === 0) return;

            log(`Zone "${zone.name}" contains ${tabs.length} tabs:`);
            tabs.forEach((tab, index) => {
                const appName = tab.app ? tab.app.get_name() : 'N/A';
                const windowTitle = tab.window.get_title() || 'N/A';
                const wmClass = tab.window.get_wm_class() || 'N/A';
                log(`  - [${index}] App='${appName}', Title='${windowTitle}', WMClass='${wmClass}'`);
            });
        });
    }

    _findBestZoneForWindow(window) {
        if (!window) return null;
        const frame = window.get_frame_rect();
        const centerX = frame.x + frame.width / 2;
        const centerY = frame.y + frame.height / 2;
        return this._findZoneAt(centerX, centerY);
    }

    _findZoneAt(x, y) {
        const monitorIndex = global.display.get_monitor_index_for_rect(
            new Mtk.Rectangle({ x, y, width: 1, height: 1 })
        );
        const monitor = Main.layoutManager.monitors[monitorIndex];
        if (!monitor) return null;

        for (const zone of this._zones) {
            if (zone.monitorIndex !== monitorIndex) continue;

            const zoneRect = {
                x: monitor.x + zone.x,
                y: monitor.y + zone.y,
                width: zone.width,
                height: zone.height,
            };

            if (x >= zoneRect.x && x <= zoneRect.x + zoneRect.width &&
                y >= zoneRect.y && y <= zoneRect.y + zoneRect.height) {
                return zone;
            }
        }
        return null;
    }

    _findZoneForWindow(window) {
        return this._zones.find(zone => zone.containsWindow(window));
    }
}



===== FILE: ./modules/Zone.js =====
// modules/Zone.js
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Meta from 'gi://Meta';
import GLib from 'gi://GLib';
import Clutter from 'gi://Clutter';

import { TabBar } from './TabBar.js';

const log = msg => console.log(`[TabbedTiling.Zone] ${msg}`);

export class Zone {
    constructor(zoneData, tabBarConfig, windowTracker) {
        // Copy all properties from the config
        Object.assign(this, zoneData);

        this._snappedWindows = new Set();
        this._windowTracker = windowTracker;
        // Minimal MRU tracking: most-recently activated window first
        this._history = [];
        this._activeWindow = null;
        // Allow monitor-wide “force hide” of tab bar during max/fullscreen
        this._forceHidden = false;
        // Keep window→signalIds for state watchers we attach when snapped
        this._stateWatch = new Map(); // Meta.Window -> number[]          
        
        this._tabBar = new TabBar(tabBarConfig);
        this._tabBar.connect('tab-clicked', (actor, window) => this.activateWindow(window));
        // When the close button on a tab is clicked, the 'tab-removed' signal is emitted.
        // We connect this to an action that closes the actual window.
        this._tabBar.connect('tab-removed', (actor, window) => {
            window.delete(global.get_current_time());
        });
        this._tabBar.connect('tab-moved', (actor, { fromZone, toZone, window }) => {
            // This is a placeholder for inter-zone dragging logic
        });

        this._updateTabBarPosition();
        Main.layoutManager.addChrome(this._tabBar);
    }

    setTabBarVisible(visible) {
        // Called by WindowManager to hide ALL tab bars on a monitor while
        // a snapped window is maximized/fullscreen.
        // Respect _forceHidden as an override (can be toggled by WindowManager if used).
        if (this._forceHidden) {
            this._tabBar.hide();
            return;
        }
        if (visible) {
            this._tabBar.show();
        } else {
            this._tabBar.hide();
        }
    }

    get monitor() {
        return Main.layoutManager.monitors[this.monitorIndex];
    }

    get rect() {
        if (!this.monitor) return null;
        return {
            x: this.monitor.x + this.x,
            y: this.monitor.y + this.y,
            width: this.width,
            height: this.height,
        };
    }

    _getGaps() {
        // Normalize gaps from config:
        // prefer this.gaps{top,right,bottom,left}; fall back to legacy numeric this.gap; else zeros
        const g = this.gaps && typeof this.gaps === 'object' ? this.gaps : null;
        const legacy = (typeof this.gap === 'number') ? this.gap : 0;
        return {
            top: Number(g?.top ?? legacy ?? 0),
            right: Number(g?.right ?? legacy ?? 0),
            bottom: Number(g?.bottom ?? legacy ?? 0),
            left: Number(g?.left ?? legacy ?? 0),
        };
    }

    _updateTabBarPosition() {
        if (!this.rect) return;
        const tabBarHeight = this._tabBar.height;
        const { top, right, left } = this._getGaps();
        this._tabBar.set_position(this.rect.x + left, this.rect.y + top);
        this._tabBar.set_size(this.rect.width - (left + right), tabBarHeight);
    }

    _ensureUntiled(window) {
        // Some apps (including GNOME Terminal) can be in a "tiled" state.
        // Just unmaximizing is not always enough; explicitly clear tiling.
        try {
            const maxFlags = (typeof window.get_maximized === 'function') ? window.get_maximized() : Meta.MaximizeFlags.NONE;
            if (maxFlags !== Meta.MaximizeFlags.NONE) {
                window.unmaximize(Meta.MaximizeFlags.BOTH);
            }
            if (typeof window.get_tile_type === 'function' &&
                window.get_tile_type() !== Meta.TileMode.NONE &&
                typeof window.tile === 'function') {
                window.tile(Meta.TileMode.NONE);
            }
        } catch (_) {
            // Ignore if not supported on this shell version.
        }
    }

    _twoStepMoveResize(window, x, y, w, h) {
        // Some clients ignore a single move+resize request (especially with increments).
        // Do a two-step: move first, then resize on idle, then a final move_resize as a fallback.
        window.move_frame(true, x, y);
        GLib.idle_add(GLib.PRIORITY_DEFAULT_IDLE, () => {
            window.move_resize_frame(true, x, y, w, h);
            return GLib.SOURCE_REMOVE;
        });
    }

    _attachStateWatch(window) {
        if (!window || this._stateWatch.has(window))
            return;
        const ids = [];
        // When this snapped window becomes maximized or fullscreen,
        // WindowManager will recompute monitor tab bar visibility.
        // We forward the state changes by simply emitting a synthetic size change on the zone,
        // which WindowManager also listens to via our snapped set; but to be safe, we also
        // trigger a recompute by toggling our own tab bar once (no-op if unchanged).
        const onState = () => {
            // No direct reference to WindowManager here; visibility will be driven
            // by WindowManager’s watcher. Just ensure our own bar won’t block a full-screened app.
            // If this window is max/fullscreen, hide our bar eagerly; it will be restored later.
            try {
                const isFs = (typeof window.is_fullscreen === 'function') ? window.is_fullscreen() : false;
                const isMax = (typeof window.get_maximized === 'function') ? !!window.get_maximized() : false;
                if (isFs || isMax) this._tabBar.hide();
            } catch (_) {}
        };
        try { ids.push(window.connect('notify::maximized', onState)); } catch (_) {}
        try { ids.push(window.connect('fullscreen-changed', onState)); } catch (_) {}
        try { ids.push(window.connect('notify::fullscreen', onState)); } catch (_) {}
        ids.push(window.connect('unmanaged', () => this._detachStateWatch(window)));
        this._stateWatch.set(window, ids);
    }

    _detachStateWatch(window) {
        const ids = this._stateWatch.get(window);
        if (!ids) return;
        for (const id of ids) {
            try { window.disconnect(id); } catch (_) {}
        }
        this._stateWatch.delete(window);
    }
    
    /**
     * Try to respect WM_NORMAL_HINTS resize increments for apps like GNOME Terminal.
     * There isn't a stable public GJS API to read the raw size hints directly,
     * so we use a conservative heuristic:
     *  - Detect well-known terminal classes.
     *  - Apply typical increment values observed via `xprop` (width 10px, height 19px)
     *    with base sizes (68x101). These may vary slightly with theme/fonts, but
     *    will usually be accepted by the client, ensuring snaps “stick”.
     *
     * If the window doesn't match, we return the requested size unchanged.
     */
    _quantizeToSizeHints(window, requestedW, requestedH) {
        try {
            const klass = (window.get_wm_class && window.get_wm_class()) || '';
            const isTerminal =
                klass.toLowerCase().includes('gnome-terminal') ||
                klass.toLowerCase().includes('org.gnome.terminal') ||
                klass.toLowerCase().includes('kgx') ||                      // GNOME Console
                klass.toLowerCase().includes('konsole') ||                  // KDE Konsole
                klass.toLowerCase().includes('alacritty') ||
                klass.toLowerCase().includes('kitty') ||
                klass.toLowerCase().includes('xterm');

            if (!isTerminal)
                return [requestedW, requestedH];

            // Defaults derived from your xprop for GNOME Terminal:
            //   base size: 68x101, increments: 10x19
            // NOTE: If your terminal uses different font metrics, tweak here.
            const baseW = 68;
            const baseH = 101;
            const incW  = 10;
            const incH  = 19;

            // Snap down to the nearest valid multiple so the client always accepts it.
            const adjW = baseW + Math.max(0, Math.floor((requestedW - baseW) / incW)) * incW;
            const adjH = baseH + Math.max(0, Math.floor((requestedH - baseH) / incH)) * incH;
            return [adjW, adjH];
        } catch (_e) {
            return [requestedW, requestedH];
        }
    }

    snapWindow(window) {
        if (!this.rect) return;

        // Ensure not maximized/tiled before attempting to move.
        this._ensureUntiled(window);

        const tabBarHeight = this._tabBar.height;
        const { top, right, bottom, left } = this._getGaps();
        const newX = this.rect.x + left;
        const newY = this.rect.y + top + tabBarHeight; // window below tab bar
        let newWidth = this.rect.width - (left + right);
        let newHeight = this.rect.height - (top + bottom) - tabBarHeight;

        // Respect client resize increments when applicable (e.g., terminals).
        // This prevents Mutter from ignoring our move/resize when sizes are invalid.
        const [adjW, adjH] = this._quantizeToSizeHints(window, newWidth, newHeight);
        newWidth = adjW;
        newHeight = adjH;

        // Perform a two-step move+resize to coax stubborn clients (e.g., GNOME Terminal).
        this._twoStepMoveResize(window, newX, newY, newWidth, newHeight);
        // Final belt-and-suspenders attempt with user_op=false in case the WM treats it differently.
        // (Keeps behavior you added later in the file.)        
        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 50, () => {
            try {
                window.move_resize_frame(false, newX, newY, newWidth, newHeight);
            } catch (_) {}
            return GLib.SOURCE_REMOVE;
        });

        if (!this._snappedWindows.has(window)) {
            this._snappedWindows.add(window);
            window._tilingZoneId = this.name; // Tag the window
            this._tabBar.addTab(window);
            this._attachStateWatch(window);            
        }

        this.activateWindow(window);
        this._updateVisibility();
    }

    unsnapWindow(window) {
        const wasActive = (this._activeWindow === window);
        if (this._snappedWindows.has(window)) {
            this._snappedWindows.delete(window);
            delete window._tilingZoneId;
            this._tabBar.removeTab(window);

            // Remove from MRU history (and prune any stale refs while we're here)
            this._history = this._history.filter(w => w && w !== window && this._snappedWindows.has(w));

            // If the removed one was active, try to restore the most recent valid one
            if (wasActive) {
                const fallback = this._history.find(w => this._snappedWindows.has(w));
                if (fallback) {
                    this.activateWindow(fallback);
                } else if (this._snappedWindows.size > 0) {
                    // Final fallback: first remaining window in the zone
                    const nextWindow = this._snappedWindows.values().next().value;
                    this.activateWindow(nextWindow);
                } else {
                    // Zone is empty
                    this._activeWindow = null;
                }
            }
        }
        this._updateVisibility();
    }

    activateWindow(window) {
        if (this._snappedWindows.has(window)) {
            window.activate(global.get_current_time());
            this._tabBar.setActiveTab(window);
            // Record MRU (most recent first), dedupe, cap to 5
            this._activeWindow = window;
            this._history = this._history.filter(w => w && w !== window && this._snappedWindows.has(w));
            this._history.unshift(window);
            if (this._history.length > 5)
                this._history.length = 5;            
        }
    }

    containsWindow(window) {
        return this._snappedWindows.has(window);
    }

    setForceHidden(hidden) {
        if (this._forceHidden === hidden) {
            return;
        }
        this._forceHidden = hidden;
        this._updateVisibility();
    }

    _updateVisibility() {
        const hasWindows = this._snappedWindows.size > 0;
        const shouldBeVisible = hasWindows && !this._forceHidden;
        if (shouldBeVisible)
            this._tabBar.show();
        else
            this._tabBar.hide();
    }

    reorderTabs() {
        this._tabBar.reorderTabs(this.name);
    }

    getSnappedWindows() {
        // Return a copy to allow safe iteration while the original set might be modified.
        return new Set(this._snappedWindows);
    }

    getTabs() {
        return this._tabBar.getTabs();
    }

    destroy() {
        // Unsnap all windows before destroying
        [...this._snappedWindows].forEach(win => this.unsnapWindow(win));
        if (this._tabBar) {
            this._tabBar.destroy();
            this._tabBar = null;
        }
    }
}



===== FILE: ./metadata.json =====
{
"name": "Tabbed Tiling",
"description": "A tiling window manager for GNOME Shell that uses tabs to manage windows within predefined zones.",
"uuid": "tabbedtiling@george.com",
"version": 1,
"shell-version": ["48"],
"url": "https://github.com/george/tabbed-tiling",
"session-modes": ["user"],
"settings-schema": "org.gnome.shell.extensions.tabbedtiling"
}




