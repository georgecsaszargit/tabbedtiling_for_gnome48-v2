
===== FILE: ./stylesheet.css =====
/* stylesheet.css */

.zone-highlight {
    background-color: rgba(100, 100, 255, 0.5);
    border: 2px solid rgba(200, 200, 255, 0.8);
    border-radius: 8px;
    transition-duration: 150ms;
}

.zone-tab-bar {
    padding: 0 4px;
}

.zone-tab {
    background-color: rgba(60, 60, 60, 0.9);
    border: 1px solid #222;
    border-bottom-width: 0;
    padding: 2px 8px;
    margin: 0 2px;
    transition-duration: 150ms;
}

.zone-tab:hover {
    background-color: rgba(80, 80, 80, 0.9);
}

.zone-tab:active,
.zone-tab:focus,
.zone-tab.active {
    background-color: rgba(0, 110, 200, 0.8);
    color: white;
    border-color: #555;
}

.zone-tab-content {
    spacing: 6px;
}

.zone-tab-app-icon {
}

.zone-tab-label {
}

.zone-tab-close-button {
    background-color: transparent;
    border: none;
    padding: 2px;
    border-radius: 99px;
}

.zone-tab-close-button:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

/* --- Grouping Styles --- */
.zone-tab.grouped-start,
.zone-tab.grouped-middle,
.zone-tab.grouped-end {
    border-color: #4A90E2;
}

.zone-tab.grouped-start {
    border-right-width: 0;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    margin-right: 0;
}

.zone-tab.grouped-middle {
    border-left-width: 0;
    border-right-width: 0;
    border-radius: 0;
    margin-left: 0;
    margin-right: 0;
}

.zone-tab.grouped-end {
    border-left-width: 0;
    border-top-left-radius: 0;
    border-bottom-left-radius: 0;
    margin-left: 0;
}



===== FILE: ./extension.js =====
// extension.js
import { Extension } from 'resource:///org/gnome/shell/extensions/extension.js';
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';

import { WindowManager } from './modules/WindowManager.js';
import { ConfigManager } from './modules/ConfigManager.js';
import { Highlighter } from './modules/Highlighter.js';

const log = msg => console.log(`[TabbedTiling] ${msg}`);

export default class TabbedTilingExtension extends Extension {
    constructor(metadata) {
        super(metadata);
        this._configManager = null;
        this._windowManager = null;
        this._highlighter = null;
        this._configFileMonitor = null;
        this._previewFileMonitor = null;
    }

    enable() {
        log('Enabling...');

        this._configManager = new ConfigManager();
        this._highlighter = new Highlighter();
        this._windowManager = new WindowManager(this._configManager, this._highlighter);

        try {
            this._windowManager.enable();
            this._monitorConfigFiles();
            log('Enabled successfully.');
        } catch (e) {
            log(`Error during enable: ${e}`);
            this.disable();
        }
    }

    disable() {
        log('Disabling...');

        if (this._configFileMonitor) {
            this._configFileMonitor.cancel();
            this._configFileMonitor = null;
        }
        if (this._previewFileMonitor) {
            this._previewFileMonitor.cancel();
            this._previewFileMonitor = null;
        }

        if (this._windowManager) {
            this._windowManager.disable();
            this._windowManager = null;
        }

        if (this._highlighter) {
            this._highlighter.destroy();
            this._highlighter = null;
        }

        this._configManager = null;
        log('Disabled.');
    }

    _monitorConfigFiles() {
        // Monitor the main config file for changes from the preferences window
        const configFile = this._configManager.getConfigFile();
        this._configFileMonitor = configFile.monitor(Gio.FileMonitorFlags.NONE, null);
        this._configFileMonitor.connect('changed', (monitor, file, otherFile, eventType) => {
            if (eventType === Gio.FileMonitorEvent.CHANGES_DONE_HINT) {
                log('Config file changed, reloading zones...');
                GLib.timeout_add(GLib.PRIORITY_DEFAULT, 100, () => {
                    this._windowManager.reloadConfiguration();
                    return GLib.SOURCE_REMOVE;
                });
            }
        });

        // Monitor the preview file for requests from the preferences window
        const previewFile = this._configManager.getPreviewFile();
        this._previewFileMonitor = previewFile.monitor(Gio.FileMonitorFlags.NONE, null);
        this._previewFileMonitor.connect('changed', (monitor, file, otherFile, eventType) => {
            if (eventType === Gio.FileMonitorEvent.CHANGES_DONE_HINT) {
                log('Preview file changed, showing preview...');
                const zones = this._configManager.loadPreviewZones();
                if (zones) {
                    this._highlighter.showAllPreviews(zones);
                }
            }
        });
    }
}



===== FILE: ./prefs.js =====
// prefs.js — TabbedTiling preferences (GNOME 48 / GJS)
// Works on X11; uses Adw, Gtk, GObject. Stores config in ~/.config/tabbedtiling/config.json

import Gio from 'gi://Gio';
import Gtk from 'gi://Gtk';
import Adw from 'gi://Adw';
import GLib from 'gi://GLib';
import GObject from 'gi://GObject';

import { ExtensionPreferences, gettext as _ } from 'resource:///org/gnome/Shell/Extensions/js/extensions/prefs.js';

// If you have a local ConfigManager module, you can keep using it.
// This file includes minimal file I/O, so ConfigManager is optional.
// import { ConfigManager } from './modules/ConfigManager.js';

const log = (msg) => console.log(`[TabbedTilingPrefs] ${msg}`);

const CONFIG_DIR = GLib.build_filenamev([GLib.get_home_dir(), '.config', 'tabbedtiling']);
const CONFIG_PATH = GLib.build_filenamev([CONFIG_DIR, 'config.json']);
const PREVIEW_PATH = GLib.build_filenamev([CONFIG_DIR, 'preview.json']);

function ensureConfigDir() {
    try {
        const f = Gio.File.new_for_path(CONFIG_DIR);
        if (!f.query_exists(null))
            f.make_directory_with_parents(null);
    } catch (e) {
        log(`Failed to ensure config dir: ${e}`);
    }
}

function defaultConfig() {
    return {
        zones: [],
        tabBar: {
            height: 32,
            backgroundColor: 'rgba(30,30,30,0.85)',
            cornerRadius: 8,
            iconSize: 16,
            fontSize: 10, // in points (pt)
            spacing: 4, // between tabs
            maxWidth: 250, // max width of a single tab
            titleSource: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            groupingCriteria: 'appName', // 'appName', 'wmClass'
            closeButtonSize: 12,    
            sortingCriteria: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            sortingOrder: 'ASC', // 'ASC', 'DESC'                    
        },
    };
}

function loadConfig() {
    try {
        const file = Gio.File.new_for_path(CONFIG_PATH);
        if (!file.query_exists(null)) {
            log('Config not found; using defaults.');
            return defaultConfig();
        }
        const [ok, bytes] = file.load_contents(null);
        if (!ok) {
            log('Failed to read config; using defaults.');
            return defaultConfig();
        }
        const json = new TextDecoder().decode(bytes);
        const parsed = JSON.parse(json);
        if (!parsed || typeof parsed !== 'object')
            return defaultConfig();
        parsed.zones ??= [];
        parsed.tabBar ??= defaultConfig().tabBar;
        return parsed;
    } catch (e) {
        log(`Error loading config: ${e}`);
        return defaultConfig();
    }
}

function saveConfig(cfg) {
    try {
        ensureConfigDir();
        const file = Gio.File.new_for_path(CONFIG_PATH);
        const json = JSON.stringify(cfg, null, 2);
        file.replace_contents(
            new TextEncoder().encode(json),
            null,
            false, // make_backup
            Gio.FileCreateFlags.REPLACE_DESTINATION,
            null
        );
        log(`Config saved to ${CONFIG_PATH}`);
        return true;
    } catch (e) {
        log(`Error saving config: ${e}`);
        return false;
    }
}

// ---------- Zone Editor Row ----------

/**
 * ZoneEditorRow
 * Expandable row to edit a single zone.
 * Zone fields: name, monitorIndex, x, y, width, height, gap, isPrimary
 */
const ZoneEditorRow = GObject.registerClass(
class ZoneEditorRow extends Adw.ExpanderRow {
    _init(zoneData, onRemove) {
        super._init({
            title: zoneData?.name || _('Unnamed Zone'),
            subtitle: `X:${zoneData?.x ?? 0}, Y:${zoneData?.y ?? 0}, W:${zoneData?.width ?? 0}, H:${zoneData?.height ?? 0}`,
            expanded: false,
        });

        this._onRemove = onRemove;
        this._zone = {
            name: zoneData?.name ?? '',
            monitorIndex: zoneData?.monitorIndex ?? 0,
            x: zoneData?.x ?? 0,
            y: zoneData?.y ?? 0,
            width: zoneData?.width ?? 0,
            height: zoneData?.height ?? 0,
            gap: zoneData?.gap ?? 0,
            isPrimary: zoneData?.isPrimary ?? false,
        };

        // Action row (right side) — Remove button
        const removeBtn = new Gtk.Button({ label: _('Remove'), valign: Gtk.Align.CENTER });
        removeBtn.add_css_class('destructive-action');
        removeBtn.connect('clicked', () => {
            if (typeof this._onRemove === 'function')
                this._onRemove(this);
        });
        this.add_action(removeBtn);

        // Content grid
        const grid = new Gtk.Grid({ column_spacing: 12, row_spacing: 6, margin_top: 6, margin_bottom: 6 });
        this.add_row(grid);

        // Helper builders
        const labeledEntry = (label, initial, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const entry = new Gtk.Entry({ hexpand: true, text: `${initial ?? ''}` });
            entry.connect('changed', () => onChanged(entry.get_text()));
            row.add_suffix(entry);
            row.activatable_widget = entry;
            return [row, entry];
        };

        const labeledSpin = (label, initial, min, max, step, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const adj = new Gtk.Adjustment({ lower: min, upper: max, step_increment: step, page_increment: step * 10, value: initial });
            const spin = new Gtk.SpinButton({ halign: Gtk.Align.END, adjustment: adj, climb_rate: 1, digits: 0 });
            spin.connect('value-changed', () => onChanged(spin.get_value_as_int()));
            row.add_suffix(spin);
            row.activatable_widget = spin;
            return [row, spin];
        };

        const labeledSwitch = (label, initial, onChanged) => {
            const row = new Adw.ActionRow({ title: label });
            const sw = new Gtk.Switch({ active: initial, halign: Gtk.Align.END });
            sw.connect('state-set', (_w, state) => {
                onChanged(state);
                return false; // allow default
            });
            row.add_suffix(sw);
            row.activatable_widget = sw;
            return [row, sw];
        };

        // Name
        const [nameRow, nameEntry] = labeledEntry(_('Name'), this._zone.name, (v) => {
            this._zone.name = v;
            this.title = v || _('Unnamed Zone');
        });
        grid.attach(nameRow, 0, 0, 1, 1);

        // Monitor index
        const [monRow, monSpin] = labeledSpin(_('Monitor Index'), this._zone.monitorIndex, 0, 63, 1, (v) => {
            this._zone.monitorIndex = v;
        });
        grid.attach(monRow, 0, 1, 1, 1);

        // X, Y, Width, Height
        const [xRow, xSpin] = labeledSpin(_('X'), this._zone.x, -10000, 10000, 1, (v) => { this._zone.x = v; this._refreshSubtitle(); });
        grid.attach(xRow, 0, 2, 1, 1);
        const [yRow, ySpin] = labeledSpin(_('Y'), this._zone.y, -10000, 10000, 1, (v) => { this._zone.y = v; this._refreshSubtitle(); });
        grid.attach(yRow, 0, 3, 1, 1);
        const [wRow, wSpin] = labeledSpin(_('Width'), this._zone.width, 0, 100000, 1, (v) => { this._zone.width = v; this._refreshSubtitle(); });
        grid.attach(wRow, 0, 4, 1, 1);
        const [hRow, hSpin] = labeledSpin(_('Height'), this._zone.height, 0, 100000, 1, (v) => { this._zone.height = v; this._refreshSubtitle(); });
        grid.attach(hRow, 0, 5, 1, 1);

        // Gap
        const [gapRow, gapSpin] = labeledSpin(_('Gap'), this._zone.gap, 0, 256, 1, (v) => { this._zone.gap = v; });
        grid.attach(gapRow, 0, 6, 1, 1);

        // isPrimary
        const [primRow, primSwitch] = labeledSwitch(_('Primary Zone'), this._zone.isPrimary, (v) => { this._zone.isPrimary = v; });
        grid.attach(primRow, 0, 7, 1, 1);
    }

    _refreshSubtitle() {
        this.subtitle = `X:${this._zone.x}, Y:${this._zone.y}, W:${this._zone.width}, H:${this._zone.height}`;
    }

    getZone() {
        return { ...this._zone };
    }
});

// ---------- Preferences Window ----------

export default class TabbedTilingPrefs extends ExtensionPreferences {
    _createSpinRow(parentGroup, title, initialValue, min, max, step) {
        const row = new Adw.ActionRow({ title });
        const adj = new Gtk.Adjustment({
            lower: min,
            upper: max,
            step_increment: step,
            page_increment: step * 10,
            value: initialValue,
        });
        const spin = new Gtk.SpinButton({
            halign: Gtk.Align.END,
            adjustment: adj,
            climb_rate: 1,
            digits: 0,
        });
        row.add_suffix(spin);
        row.activatable_widget = spin;
        parentGroup.add(row);
        return spin;
    }
    fillPreferencesWindow(window) {
        // Make sure Adw preferences styling is initialized
        Adw.init();

        const cfg = loadConfig();

        const page = new Adw.PreferencesPage();
        window.add(page);

        // Zone Generator Group
        const generatorGroup = new Adw.PreferencesGroup({
            title: _('Zone Generator'),
            description: _('Quickly create a set of horizontal zones for a monitor. This will replace existing zones on the selected monitor.'),
        });
        page.add(generatorGroup);

        const monSpin = this._createSpinRow(generatorGroup, _('Monitor Index'), 0, 0, 16, 1);
        const resWSpin = this._createSpinRow(generatorGroup, _('Monitor Resolution Width'), 1920, 0, 10000, 1);
        const resHSpin = this._createSpinRow(generatorGroup, _('Monitor Resolution Height'), 1080, 0, 10000, 1);
        const xSpin = this._createSpinRow(generatorGroup, _('Start X Coordinate'), 0, 0, 10000, 1);
        const ySpin = this._createSpinRow(generatorGroup, _('Start Y Coordinate'), 0, 0, 10000, 1);
        const numZonesSpin = this._createSpinRow(generatorGroup, _('Number of Zones'), 2, 1, 16, 1);

        const genRow = new Adw.ActionRow();
        const genBtn = new Gtk.Button({ label: _('Generate Zones'), halign: Gtk.Align.CENTER });
        genRow.set_child(genBtn);
        generatorGroup.add(genRow);        

        // Zones group
        const zonesGroup = new Adw.PreferencesGroup({ title: _('Zones'), description: _('Define rectangles for snapping and tabbing.') });
        page.add(zonesGroup);

        // Add New Zone header with button
        const addRow = new Adw.ActionRow({ title: _('Add New Zone'), subtitle: _('Insert a new zone with default values') });
        const addBtn = new Gtk.Button({ label: _('Add') });
        addBtn.connect('clicked', () => this._addZoneRow(null, zonesGroup));
        addRow.add_suffix(addBtn);
        addRow.activatable_widget = addBtn;
        zonesGroup.add(addRow);

        // Existing zones
        this._zoneRows = [];
        for (const z of cfg.zones) {
            this._addZoneRow(z, zonesGroup);
        }

        genBtn.connect('clicked', () => {
            const monitorIndex = monSpin.get_value_as_int();
            const resW = resWSpin.get_value_as_int();
            const resH = resHSpin.get_value_as_int();
            const startX = xSpin.get_value_as_int();
            const startY = ySpin.get_value_as_int();
            const numZones = numZonesSpin.get_value_as_int();

            // Remove existing zones for this monitor
            const rowsToRemove = this._zoneRows.filter(r => r.getZone().monitorIndex === monitorIndex);
            rowsToRemove.forEach(r => {
                zonesGroup.remove(r);
                const index = this._zoneRows.indexOf(r);
                if (index > -1) this._zoneRows.splice(index, 1);
            });

            // Calculate and add new zones
            const availableWidth = resW - startX;
            const zoneWidth = Math.floor(availableWidth / numZones);
            const zoneHeight = resH - startY;

            if (zoneWidth <= 0 || zoneHeight <= 0) {
                this._toast(window, _('Invalid dimensions. Check resolution and start coordinates.'));
                return;
            }

            for (let i = 0; i < numZones; i++) {
                const zoneData = {
                    name: `Monitor ${monitorIndex} Zone ${i + 1}`,
                    monitorIndex, x: startX + (i * zoneWidth), y: startY,
                    width: zoneWidth, height: zoneHeight, gap: 8, isPrimary: (i === 0),
                };
                this._addZoneRow(zoneData, zonesGroup);
            }
            this._toast(window, _(`Generated ${numZones} zones for monitor ${monitorIndex}.`));
        });

        // --- Tab Appearance Group ---
        const tabBarGroup = new Adw.PreferencesGroup({ title: _('Tab Appearance'), description: _('Configure the look and feel of tab bars and tabs.') });
        page.add(tabBarGroup);
        // Merge loaded config with defaults to prevent errors from missing keys
        const cfgTabBar = { ...defaultConfig().tabBar, ...(cfg.tabBar ?? {}) };

        // Height        
        const heightRow = new Adw.ActionRow({ title: _('Height (px)') });
        const heightAdj = new Gtk.Adjustment({ lower: 16, upper: 256, step_increment: 1, value: cfgTabBar.height ?? 32 });
        const heightSpin = new Gtk.SpinButton({ adjustment: heightAdj, digits: 0, halign: Gtk.Align.END });
        heightRow.add_suffix(heightSpin);
        heightRow.activatable_widget = heightSpin;
        tabBarGroup.add(heightRow);
        
        // Background Color
        const colorRow = new Adw.ActionRow({ title: _('Background Color'), subtitle: _('e.g., rgba(30, 30, 30, 0.85)') });
        const colorEntry = new Gtk.Entry({ text: cfgTabBar.backgroundColor ?? 'rgba(30,30,30,0.85)', hexpand: true });
        colorRow.add_suffix(colorEntry);
        colorRow.activatable_widget = colorEntry;
        tabBarGroup.add(colorRow);

        // Corner Radius
        const radiusRow = new Adw.ActionRow({ title: _('Tab Corner Radius (px)') });
        const radiusAdj = new Gtk.Adjustment({ lower: 0, upper: 32, step_increment: 1, value: cfgTabBar.cornerRadius ?? 8 });
        const radiusSpin = new Gtk.SpinButton({ adjustment: radiusAdj, digits: 0, halign: Gtk.Align.END });
        radiusRow.add_suffix(radiusSpin);
        radiusRow.activatable_widget = radiusSpin;
        tabBarGroup.add(radiusRow);

        // Icon Size
        const iconSizeRow = new Adw.ActionRow({ title: _('Icon Size (px)') });
        const iconSizeAdj = new Gtk.Adjustment({ lower: 8, upper: 48, step_increment: 1, value: cfgTabBar.iconSize ?? 16 });
        const iconSizeSpin = new Gtk.SpinButton({ adjustment: iconSizeAdj, digits: 0, halign: Gtk.Align.END });
        iconSizeRow.add_suffix(iconSizeSpin);
        iconSizeRow.activatable_widget = iconSizeSpin;
        tabBarGroup.add(iconSizeRow);

        // Font Size
        const fontSizeRow = new Adw.ActionRow({ title: _('Font Size (pt)') });
        const fontSizeAdj = new Gtk.Adjustment({ lower: 6, upper: 24, step_increment: 1, value: cfgTabBar.fontSize ?? 10 });
        const fontSizeSpin = new Gtk.SpinButton({ adjustment: fontSizeAdj, digits: 0, halign: Gtk.Align.END });
        fontSizeRow.add_suffix(fontSizeSpin);
        fontSizeRow.activatable_widget = fontSizeSpin;
        tabBarGroup.add(fontSizeRow);

        // Spacing
        const spacingRow = new Adw.ActionRow({ title: _('Spacing between Tabs (px)') });
        const spacingAdj = new Gtk.Adjustment({ lower: 0, upper: 32, step_increment: 1, value: cfgTabBar.spacing ?? 4 });
        const spacingSpin = new Gtk.SpinButton({ adjustment: spacingAdj, digits: 0, halign: Gtk.Align.END });
        spacingRow.add_suffix(spacingSpin);
        spacingRow.activatable_widget = spacingSpin;
        tabBarGroup.add(spacingRow);

        // Max Width
        const maxWidthRow = new Adw.ActionRow({ title: _('Max Tab Width (px)') });
        const maxWidthAdj = new Gtk.Adjustment({ lower: 50, upper: 1000, step_increment: 10, value: cfgTabBar.maxWidth ?? 250 });
        const maxWidthSpin = new Gtk.SpinButton({ adjustment: maxWidthAdj, digits: 0, halign: Gtk.Align.END });
        maxWidthRow.add_suffix(maxWidthSpin);
        maxWidthRow.activatable_widget = maxWidthSpin;
        tabBarGroup.add(maxWidthRow);

        // Close Button Size
        const closeButtonSizeRow = new Adw.ActionRow({ title: _('Close Button Size (px)') });
        const closeButtonSizeAdj = new Gtk.Adjustment({ lower: 8, upper: 32, step_increment: 1, value: cfgTabBar.closeButtonSize ?? 12 });
        const closeButtonSizeSpin = new Gtk.SpinButton({ adjustment: closeButtonSizeAdj, digits: 0, halign: Gtk.Align.END });
        closeButtonSizeRow.add_suffix(closeButtonSizeSpin);
        closeButtonSizeRow.activatable_widget = closeButtonSizeSpin;
        tabBarGroup.add(closeButtonSizeRow);

        // --- Tab Behavior Group ---
        const behaviorGroup = new Adw.PreferencesGroup({ title: _('Tab Behavior'), description: _('Configure tab titles and grouping.') });
        page.add(behaviorGroup);

        // Title Source
        const titleSourceRow = new Adw.ActionRow({ title: _('Tab Title Source') });
        const titleModel = new Gtk.StringList();
        titleModel.append(_('Window Title'));
        titleModel.append(_('Application Name'));
        titleModel.append(_('WM_CLASS'));
        const titleDropdown = new Gtk.DropDown({ model: titleModel });
        const titleMap = { 'windowTitle': 0, 'appName': 1, 'wmClass': 2 };
        titleDropdown.set_selected(titleMap[cfgTabBar.titleSource] ?? 0);
        titleSourceRow.add_suffix(titleDropdown);
        titleSourceRow.activatable_widget = titleDropdown;
        behaviorGroup.add(titleSourceRow);

        // Grouping Criteria
        const groupSourceRow = new Adw.ActionRow({ title: _('Tab Grouping Criteria') });
        const groupModel = new Gtk.StringList();
        groupModel.append(_('Application Name'));
        groupModel.append(_('WM_CLASS'));
        const groupDropdown = new Gtk.DropDown({ model: groupModel });
        const groupMap = { 'appName': 0, 'wmClass': 1 };
        groupDropdown.set_selected(groupMap[cfgTabBar.groupingCriteria] ?? 0);
        groupSourceRow.add_suffix(groupDropdown);
        groupSourceRow.activatable_widget = groupDropdown;
        behaviorGroup.add(groupSourceRow);        

        // Sorting Criteria
        const sortSourceRow = new Adw.ActionRow({ title: _('Sorting Criteria') });
        const sortModel = new Gtk.StringList();
        sortModel.append(_('Window Title'));
        sortModel.append(_('Application Name'));
        sortModel.append(_('WM_CLASS'));
        const sortDropdown = new Gtk.DropDown({ model: sortModel });
        const sortMap = { 'windowTitle': 0, 'appName': 1, 'wmClass': 2 };
        sortDropdown.set_selected(sortMap[cfgTabBar.sortingCriteria] ?? 0);
        sortSourceRow.add_suffix(sortDropdown);
        sortSourceRow.activatable_widget = sortDropdown;
        behaviorGroup.add(sortSourceRow);

        // Sorting Order
        const sortOrderRow = new Adw.ActionRow({ title: _('Sorting Order') });
        const orderModel = new Gtk.StringList();
        orderModel.append(_('Ascending'));
        orderModel.append(_('Descending'));
        const orderDropdown = new Gtk.DropDown({ model: orderModel });
        const orderMap = { 'ASC': 0, 'DESC': 1 };
        orderDropdown.set_selected(orderMap[cfgTabBar.sortingOrder] ?? 0);
        sortOrderRow.add_suffix(orderDropdown);
        sortOrderRow.activatable_widget = orderDropdown;
        behaviorGroup.add(sortOrderRow);

        // Footer: Save & Apply (must be added to a PreferencesGroup, not directly to the Page)
        const footer = new Adw.ActionRow();

        const previewBtn = new Gtk.Button({ label: _('Preview Zones') });
        previewBtn.connect('clicked', () => {
            const zones = this._zoneRows.map(r => r.getZone());
            try {
                ensureConfigDir();
                const file = Gio.File.new_for_path(PREVIEW_PATH);
                const json = JSON.stringify(zones);
                file.replace_contents(
                    new TextEncoder().encode(json), null, false,
                    Gio.FileCreateFlags.REPLACE_DESTINATION, null
                );
                this._toast(window, _('Showing zone preview for 5 seconds.'));
            } catch (e) {
                log(`Error saving preview file: ${e}`);
                this._toast(window, _('Could not show preview.'));
            }
        });
        footer.add_prefix(previewBtn);
        const saveBtn = new Gtk.Button({ label: _('Save and Apply') });
        saveBtn.add_css_class('suggested-action');
        saveBtn.connect('clicked', () => {
            const newCfg = this._collectConfig(
                cfg, {
                    heightSpin, colorEntry, radiusSpin, closeButtonSizeSpin,
                    iconSizeSpin, fontSizeSpin, spacingSpin,
                    maxWidthSpin, titleDropdown, groupDropdown,
                    sortDropdown, orderDropdown
                }
            );
            if (saveConfig(newCfg)) {
                this._toast(window, _('Configuration saved.'));
            } else {
                this._toast(window, _('Failed to save configuration.'));
            }
        });
        footer.add_suffix(saveBtn);

        const actionsGroup = new Adw.PreferencesGroup({ title: _('Actions') });
        actionsGroup.add(footer);
        page.add(actionsGroup);
    }

    _addZoneRow(zoneOrNull, zonesGroup) {
        const initial = zoneOrNull ?? {
            name: '',
            monitorIndex: 0,
            x: 0, y: 0, width: 800, height: 600,
            gap: 8,
            isPrimary: false,
        };

        const row = new ZoneEditorRow(initial, (rowSelf) => {
            // remove from UI and local list
            zonesGroup.remove(rowSelf);
            this._zoneRows = this._zoneRows.filter(r => r !== rowSelf);
        });

        this._zoneRows.push(row);
        zonesGroup.add(row);
    }

    _collectConfig(existingCfg, widgets) {
        const zones = this._zoneRows.map(r => r.getZone());
        
        const titleMap = ['windowTitle', 'appName', 'wmClass'];
        const groupMap = ['appName', 'wmClass'];        
        const sortMap = ['windowTitle', 'appName', 'wmClass'];
        const orderMap = ['ASC', 'DESC'];

        const tabBar = {
            ...(existingCfg.tabBar ?? defaultConfig().tabBar),
            height: widgets.heightSpin.get_value_as_int(),
            backgroundColor: widgets.colorEntry.get_text(),
            cornerRadius: widgets.radiusSpin.get_value_as_int(),
            iconSize: widgets.iconSizeSpin.get_value_as_int(),
            fontSize: widgets.fontSizeSpin.get_value_as_int(),
            spacing: widgets.spacingSpin.get_value_as_int(),
            maxWidth: widgets.maxWidthSpin.get_value_as_int(),
            titleSource: titleMap[widgets.titleDropdown.get_selected()],
            groupingCriteria: groupMap[widgets.groupDropdown.get_selected()],
            closeButtonSize: widgets.closeButtonSizeSpin.get_value_as_int(),
            sortingCriteria: sortMap[widgets.sortDropdown.get_selected()],
            sortingOrder: orderMap[widgets.orderDropdown.get_selected()],
        };

        // Basic validation: drop zones with non-positive size
        const saneZones = zones.filter(z => (z.width > 0 && z.height > 0));

        return { zones: saneZones, tabBar };
    }

    _toast(window, text) {
        // If running inside gnome-extensions-app, we can pop a simple banner using Adw.ToastOverlay if present.
        // Fall back to console.
        try {
            if (!this._overlay) {
                this._overlay = new Adw.ToastOverlay();
                // Wrap current content
                const child = window.get_content();
                window.set_content(this._overlay);
                if (child)
                    this._overlay.set_child(child);
            }
            const toast = new Adw.Toast({ title: text, timeout: 3 });
            this._overlay.add_toast(toast);
        } catch (e) {
            log(`${text} (no toast overlay available)`);
        }
    }
}




===== FILE: ./modules/Tab.js =====
// modules/Tab.js
import St from 'gi://St';
import GObject from 'gi://GObject';
import Pango from 'gi://Pango';
import Clutter from 'gi://Clutter';

export const Tab = GObject.registerClass({
    GTypeName: 'TabbedTiling_Tab',
    Signals: {
        'close-clicked': {},
    },
}, class Tab extends St.Button {
    _init(window, app, config) {
        super._init({
            style_class: 'zone-tab',
            can_focus: true,
            reactive: true,
        });

        this.window = window;
        this.app = app;
        this._config = config; // Save config        

        const box = new St.BoxLayout({
            style_class: 'zone-tab-content',
            x_expand: true,
        });
        this.set_child(box);

        // App Icon
        if (app) {
            const icon = new St.Icon({
                gicon: app.get_icon(),
                style_class: 'zone-tab-app-icon',
                icon_size: this._config.iconSize ?? 16,                
            });
            box.add_child(icon);
        }

        // Title Label
        const label = new St.Label({
            text: this.getTabTitle(),
            y_align: Clutter.ActorAlign.CENTER,
            style_class: 'zone-tab-label',
        });
        // Apply font size from config
        label.style = `font-size: ${this._config.fontSize ?? 10}pt;`;        
        label.clutter_text.set_ellipsize(Pango.EllipsizeMode.END);
        box.add_child(label);

        // Spacer to push the close button to the right
        const spacer = new St.Bin({ x_expand: true });
        box.add_child(spacer);

        // Close Button
        const closeButton = new St.Button({ style_class: 'zone-tab-close-button' });
        closeButton.set_child(new St.Icon({
            icon_name: 'window-close-symbolic',
            icon_size: this._config.closeButtonSize ?? 12,
        }));
        closeButton.connect('clicked', () => this.emit('close-clicked'));
        box.add_child(closeButton);

        // Connect to window title changes to update the tab
        this._titleChangedId = window.connect('notify::title', () => {
            label.set_text(this.getTabTitle());
        });
    }

    getTabTitle() {
        const source = this._config.titleSource ?? 'windowTitle';
        if (source === 'appName' && this.app) return this.app.get_name();
        if (source === 'wmClass') return this.window.get_wm_class();

        // Default to window title with fallbacks
        return this.window.get_title() || (this.app ? this.app.get_name() : null) || this.window.get_wm_class() || 'Untitled';
    }

    getGroupingId() {
        const criteria = this._config.groupingCriteria ?? 'appName';
        if (criteria === 'wmClass') return this.window.get_wm_class();
        // Default to app name
        return this.app ? this.app.get_id() : (this.window.get_wm_class() || 'unknown');
    }

    getSortKey() {
        const criteria = this._config.sortingCriteria ?? 'windowTitle';
        if (criteria === 'appName' && this.app) return this.app.get_name();
        if (criteria === 'wmClass') return this.window.get_wm_class();

        // Default to window title with fallbacks
        return this.window.get_title() || (this.app ? this.app.get_name() : null) || this.window.get_wm_class() || 'Untitled';
    }

    getGroupSortKey() {
        const criteria = this._config.groupingCriteria ?? 'appName';
        if (criteria === 'wmClass') return this.window.get_wm_class() || 'unknown';
        // Default to app name, using the *display name* for sorting
        return this.app ? this.app.get_name() : (this.window.get_wm_class() || 'unknown');
    }

    destroy() {
        if (this._titleChangedId && this.window) {
            try {
                this.window.disconnect(this._titleChangedId);
            } catch (e) { /* ignore */ }
        }
        super.destroy();
    }
});



===== FILE: ./modules/ConfigManager.js =====
// modules/ConfigManager.js
import Gio from 'gi://Gio';
import GLib from 'gi://GLib';

const log = msg => console.log(`[TabbedTiling.ConfigManager] ${msg}`);
const CONFIG_DIR = 'tabbedtiling';
const CONFIG_FILENAME = 'config.json';
const PREVIEW_FILENAME = 'preview.json';

export class ConfigManager {
    constructor() {
        this._configDir = Gio.File.new_for_path(GLib.get_user_config_dir()).get_child(CONFIG_DIR);
        this._configFile = this._configDir.get_child(CONFIG_FILENAME);
        this._previewFile = this._configDir.get_child(PREVIEW_FILENAME);
        this._config = null;

        this._ensureDirExists();
    }

    _ensureDirExists() {
        if (!this._configDir.query_exists(null)) {
            log('Config directory not found, creating it.');
            try {
                this._configDir.make_directory_with_parents(null);
            } catch (e) {
                log(`Error creating config directory: ${e}`);
            }
        }
    }
    
    _getDefaultConfig() {
        return {
            zones: [],
            tabBar: {
                height: 32,
                backgroundColor: 'rgba(30, 30, 30, 0.85)',
                cornerRadius: 8,
                iconSize: 16,
            fontSize: 10, // in points (pt)
            spacing: 4, // between tabs
            maxWidth: 250, // max width of a single tab
            titleSource: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            groupingCriteria: 'appName', // 'appName', 'wmClass'
            closeButtonSize: 12,
            sortingCriteria: 'windowTitle', // 'windowTitle', 'appName', 'wmClass'
            sortingOrder: 'ASC', // 'ASC', 'DESC'            
			}
        };
    }

    getConfigFile() {
        return this._configFile;
    }

    getPreviewFile() {
        return this._previewFile;
    }

    load() {
        if (!this._configFile.query_exists(null)) {
            log('Config file not found, creating a default one.');
            this._config = this._getDefaultConfig();
            this.save(this._config);
        } else {
            try {
                const [ok, contents] = this._configFile.load_contents(null);
                if (ok) {
                    this._config = JSON.parse(new TextDecoder().decode(contents));
                } else {
                    throw new Error("Failed to load file contents.");
                }
            } catch (e) {
                log(`Error reading or parsing config file: ${e}. Using default config.`);
                this._config = this._getDefaultConfig();
            }
        }
        return this._config;
    }

    getConfig() {
        return this._config || this.load();
    }

    save(configObject) {
        try {
            const data = JSON.stringify(configObject, null, 2);
            this._configFile.replace_contents(
                data,
                null,
                false,
                Gio.FileCreateFlags.REPLACE_DESTINATION,
                null
            );
            this._config = configObject;
            log('Configuration saved successfully.');
        } catch (e) {
            log(`Error saving configuration: ${e}`);
        }
    }

    savePreviewZones(zones) {
        try {
            const data = JSON.stringify(zones);
            this._previewFile.replace_contents(
                data, null, false,
                Gio.FileCreateFlags.REPLACE_DESTINATION, null
            );
        } catch (e) {
            log(`Error saving preview file: ${e}`);
        }
    }

    loadPreviewZones() {
        try {
            const [ok, contents] = this._previewFile.load_contents(null);
            if (ok) {
                return JSON.parse(new TextDecoder().decode(contents));
            }
        } catch (e) {
            log(`Error loading preview file: ${e}`);
        }
        return null;
    }
}



===== FILE: ./modules/TabBar.js =====
// modules/TabBar.js
import St from 'gi://St';
import GObject from 'gi://GObject';
import Clutter from 'gi://Clutter';
import Shell from 'gi://Shell';
import GLib from 'gi://GLib';
// import Meta from 'gi://Meta'; // (optional) if you want to type-check Meta.Window

import { Tab } from './Tab.js';

const log = msg => console.log(`[TabbedTiling.TabBar] ${msg}`);

export const TabBar = GObject.registerClass({
    GTypeName: 'TabbedTiling_TabBar',
    Signals: {
        // Use TYPE_OBJECT for GObject instances (e.g., Meta.Window). TYPE_POINTER causes G_POINTER conversion errors.
        'tab-clicked': { param_types: [GObject.TYPE_OBJECT] }, // Meta.Window
        'tab-removed': { param_types: [GObject.TYPE_OBJECT] }, // Meta.Window
        'tab-moved':   { param_types: [GObject.TYPE_OBJECT] }, // Custom object
    },
}, class TabBar extends St.BoxLayout {
    _init(tabBarConfig) {
        super._init({
            style_class: 'zone-tab-bar',
            reactive: true,
            visible: false,
        });
        
        this.set_height(tabBarConfig.height || 32);
        this.style = `background-color: ${tabBarConfig.backgroundColor};`;        
        this._config = tabBarConfig;
        this._tabs = new Map(); // Meta.Window -> Tab instance
        this._windowTracker = Shell.WindowTracker.get_default();
        // Use a container for tabs to manage layout. Spacing is a CSS property.
        this._tabContainer = new St.BoxLayout({
            style_class: 'zone-tab-container',
            style: `spacing: ${this._config.spacing ?? 4}px;`
        });
        this.add_child(this._tabContainer);        
    }

    addTab(window) {
        if (this._tabs.has(window)) {
            this.setActiveTab(window);
            return;
        }

        const app = this._windowTracker.get_window_app(window);
        const tab = new Tab(window, app, this._config);
        // Apply corner radius from config
        tab.style = `border-radius: ${this._config.cornerRadius ?? 8}px ${this._config.cornerRadius ?? 8}px 0 0;`;        
        
        tab.connect('close-clicked', () => this.emit('tab-removed', window));
        // Ensure the handler is a function (not an immediate call) and returns a valid Clutter event code.
        // Also accept (actor, event) signature to avoid any accidental param marshalling issues.
        tab.connect('button-press-event', (_actor, _event) => {
            try {
                this.emit('tab-clicked', window); // window is a GObject (Meta.Window), matches TYPE_OBJECT
            } catch (e) {
                logError(e, 'Emitting tab-clicked failed');
            }
            return Clutter.EVENT_STOP;
        });

        this._tabs.set(window, tab);
        this._tabContainer.add_child(tab);

        this.reorderTabs();
    }

    removeTab(window) {
        if (this._tabs.has(window)) {
            const tab = this._tabs.get(window);
            this._tabContainer.remove_child(tab);
            tab.destroy();
            this._tabs.delete(window);
            this.reorderTabs();
        }
    }
    
    setActiveTab(window) {
        for (const [win, tab] of this._tabs.entries()) {
            if (win === window) {
                tab.add_style_class_name('active');
            } else {
                tab.remove_style_class_name('active');
            }
        }
    }

    reorderTabs(zoneName = 'Unknown') {
        const tabs = this._tabContainer.get_children();

        // No need to sort 0 or 1 tab, but we must update styles to remove grouping.
        if (tabs.length < 2) {
            this._updateGroupStyles();
            return;
        }

        const sortOrder = (this._config.sortingOrder === 'DESC') ? -1 : 1;

        tabs.sort((a, b) => {
            // Primary sort is by the user-defined group criteria (using a readable name)
            const groupA = a.getGroupSortKey()?.toLowerCase() ?? '';
            const groupB = b.getGroupSortKey()?.toLowerCase() ?? '';

            if (groupA < groupB) return -1 * sortOrder;
            if (groupA > groupB) return 1 * sortOrder;

            // Secondary sort is by the user-defined sorting criteria
            const keyA = a.getSortKey()?.toLowerCase() ?? '';
            const keyB = b.getSortKey()?.toLowerCase() ?? '';

            let result = 0;
            if (keyA < keyB) result = -1;
            if (keyA > keyB) result = 1;

            return result * sortOrder;
        });

        tabs.forEach((tab, index) => {
            this._tabContainer.set_child_at_index(tab, index);
        });

        this._updateGroupStyles();
        this._updateTabSizes();
    }

    getTabs() {
        return this._tabContainer.get_children();
    }

    _updateTabSizes() {
        const children = this._tabContainer.get_children();
        if (children.length === 0) return;

        const availableWidth = this.get_width();
        const maxWidth = this._config.maxWidth ?? 250;

        // Find the preferred width of the widest tab to make all tabs equal.
        const widestPreferred = children.reduce((max, c) => {
            return Math.max(max, c.get_preferred_width(-1)[1]);
        }, 0);

        // Determine the ideal width for each tab, capped by maxWidth.
        const idealWidth = Math.min(widestPreferred, maxWidth);

        if (idealWidth * children.length > availableWidth) {
            // If the ideal width causes an overflow, shrink all tabs equally to fit.
            const newWidth = Math.floor(availableWidth / children.length);
            children.forEach(c => c.set_width(newWidth));
        } else {
            // Otherwise, set all tabs to the same ideal width.
            children.forEach(c => c.set_width(idealWidth));
        }
    }

    _updateGroupStyles() {
        const children = this._tabContainer.get_children();
        if (children.length <= 1) {
            children.forEach(c => {
                c.remove_style_class_name('grouped-start');
                c.remove_style_class_name('grouped-middle');
                c.remove_style_class_name('grouped-end');
            });
            return;
        }

        for (let i = 0; i < children.length; i++) {
            const currentTab = children[i]; // This is a Tab instance
            const prevTab = children[i - 1] ?? null;
            const nextTab = children[i + 1] ?? null;

            const currentId = currentTab.getGroupingId();
            const prevId = prevTab ? prevTab.getGroupingId() : null;
            const nextId = nextTab ? nextTab.getGroupingId() : null;

            currentTab.remove_style_class_name('grouped-start');
            currentTab.remove_style_class_name('grouped-middle');
            currentTab.remove_style_class_name('grouped-end');

            if (currentId === nextId && currentId !== prevId) {
                currentTab.add_style_class_name('grouped-start');
            } else if (currentId === prevId && currentId === nextId) {
                currentTab.add_style_class_name('grouped-middle');
            } else if (currentId === prevId && currentId !== nextId) {
                currentTab.add_style_class_name('grouped-end');
            }
        }
    }

    destroy() {
        this._tabs.forEach(tab => tab.destroy());
        this._tabs.clear();
        super.destroy();
    }
});



===== FILE: ./modules/Highlighter.js =====
// modules/Highlighter.js
import St from 'gi://St';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import GLib from 'gi://GLib';
import Clutter from 'gi://Clutter';

const PREVIEW_TIMEOUT_MS = 5000; // 5 seconds

export class Highlighter {
    constructor() {
        this._hoverHighlight = null;
        this._previewHighlights = [];
        this._previewTimeoutId = 0;
    }

    _createHighlightActor(styleClass) {
        const actor = new St.Bin({
            style_class: styleClass,
            reactive: false,
            can_focus: false,
            x_expand: true,
            y_expand: true,
        });
        Main.layoutManager.addChrome(actor, { affectsStruts: false });
        actor.set_offscreen_redirect(Clutter.OffscreenRedirect.ALWAYS);
        return actor;
    }

    showHoverHighlight(zone) {
        if (!this._hoverHighlight) {
            this._hoverHighlight = this._createHighlightActor('zone-highlight');
        }

        const monitor = Main.layoutManager.monitors[zone.monitorIndex];
        if (!monitor) return;

        this._hoverHighlight.set_position(monitor.x + zone.x, monitor.y + zone.y);
        this._hoverHighlight.set_size(zone.width, zone.height);
        this._hoverHighlight.show();
    }

    hideHoverHighlight() {
        if (this._hoverHighlight) {
            this._hoverHighlight.hide();
        }
    }

    showAllPreviews(zones) {
        this.destroyPreviews(); // Clear any existing previews

        if (this._previewTimeoutId) {
            GLib.Source.remove(this._previewTimeoutId);
        }

        zones.forEach(zone => {
            const monitor = Main.layoutManager.monitors[zone.monitorIndex];
            if (!monitor) return;

            const actor = this._createHighlightActor('zone-highlight');
            actor.set_position(monitor.x + zone.x, monitor.y + zone.y);
            actor.set_size(zone.width, zone.height);
            actor.show();
            this._previewHighlights.push(actor);
        });

        // Previews automatically hide after a timeout
        this._previewTimeoutId = GLib.timeout_add(GLib.PRIORITY_DEFAULT, PREVIEW_TIMEOUT_MS, () => {
            this.destroyPreviews();
            this._previewTimeoutId = 0;
            return GLib.SOURCE_REMOVE;
        });
    }

    destroyPreviews() {
        this._previewHighlights.forEach(actor => actor.destroy());
        this._previewHighlights = [];
    }

    destroy() {
        if (this._hoverHighlight) {
            this._hoverHighlight.destroy();
            this._hoverHighlight = null;
        }
        this.destroyPreviews();
    }
}



===== FILE: ./modules/WindowManager.js =====
// modules/WindowManager.js
import Meta from 'gi://Meta';
import Shell from 'gi://Shell';
import GLib from 'gi://GLib';
import Gio from 'gi://Gio';
import Mtk from 'gi://Mtk';
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Clutter from 'gi://Clutter';

import { Zone } from './Zone.js';

const log = (msg) => console.log(`[TabbedTiling.WindowManager] ${msg}`);

export class WindowManager {
    constructor(configManager, highlighter) {
        this._configManager = configManager;
        this._highlighter = highlighter;
        this._zones = [];
        this._signalConnections = [];
        this._windowTracker = Shell.WindowTracker.get_default();
        this._loginProxy = null;
    }

    enable() {
        log("DEBUG: enable() called.");
        this.reloadConfiguration();
        this._connectSignals();
        this._snapExistingWindows();
    }

    disable() {
        log("DEBUG: disable() called.");
        this._disconnectSignals();
        this._zones.forEach(zone => zone.destroy());
        this._zones = [];
        this._highlighter.hideHoverHighlight();
    }

    reloadConfiguration() {
        log("DEBUG: reloadConfiguration() called.");
        const config = this._configManager.load();

        this._zones.forEach(zone => zone.destroy());
        this._zones = [];

        config.zones.forEach(zoneData => {
            this._zones.push(new Zone(zoneData, config.tabBar, this._windowTracker));
        });

        log(`Loaded ${this._zones.length} zones.`);
        this._snapExistingWindows();
    }

    _connectSignals() {
        log("DEBUG: _connectSignals() called.");
        const connect = (gobj, name, cb) => {
            const id = gobj.connect(name, cb);
            this._signalConnections.push({ gobj, id });
        };

        connect(global.display, 'grab-op-begin', this._onGrabOpBegin.bind(this));
        connect(global.display, 'grab-op-end', this._onGrabOpEnd.bind(this));
        connect(global.display, 'window-created', this._onWindowCreated.bind(this));
        connect(this._windowTracker, 'tracked-windows-changed', this._onTrackedWindowsChanged.bind(this));
        connect(Main.layoutManager, 'monitors-changed', () => this.reloadConfiguration());

        // Manually create a proxy for LoginManager to handle suspend/resume.
        const LoginManagerIface = `
        <node>
            <interface name="org.freedesktop.login1.Manager">
                <signal name="PrepareForSleep">
                    <arg type="b" name="starting"/>
                </signal>
            </interface>
        </node>`;

        log("DEBUG: Attempting to create LoginManager proxy...");
        try {
            const info = Gio.DBusNodeInfo.new_for_xml(LoginManagerIface);
            const interfaceInfo = info.interfaces.find(i => i.name === 'org.freedesktop.login1.Manager');

            Gio.DBusProxy.new_for_bus(
                Gio.BusType.SYSTEM,
                Gio.DBusProxyFlags.NONE,
                interfaceInfo,
                'org.freedesktop.login1',      // name
                '/org/freedesktop/login1',      // object path
                'org.freedesktop.login1.Manager', // interface name
                null, // cancellable
                (source_object, res) => {
                    try {
                        const proxy = Gio.DBusProxy.new_for_bus_finish(res);
                        log("DEBUG: LoginManager proxy created successfully.");
                        this._loginProxy = proxy;

                        connect(this._loginProxy, 'g-signal', (p, sender, signal, params) => {
                             if (signal === 'PrepareForSleep') {
                                const starting = params.get_child_value(0).get_boolean();
                                if (!starting) {
                                    log("DEBUG: System resumed from sleep, re-snapping windows.");
                                    GLib.timeout_add(GLib.PRIORITY_DEFAULT, 1000, () => {
                                        this._snapExistingWindows();
                                        return GLib.SOURCE_REMOVE;
                                    });
                                }
                             }
                        });
                    } catch (e) {
                        log(`ERROR: Failed to finalize LoginManager proxy or connect signal. Error: ${e.message}`);
                    }
                }
            );
        } catch (e) {
            log(`ERROR: Could not create LoginManager proxy. D-Bus XML may be invalid. Error: ${e.message}`);
        }
    }

    _disconnectSignals() {
        log("DEBUG: _disconnectSignals() called.");
        this._signalConnections.forEach(({ gobj, id }) => {
            try {
                gobj.disconnect(id);
            } catch (e) {
                // Ignore errors if object is already gone
            }
        });
        this._signalConnections = [];
        this._loginProxy = null;
    }

    _isSnappable(window) {
        if (!window || window.is_fullscreen()) return false;
        const type = window.get_window_type();
        return type === Meta.WindowType.NORMAL;
    }

    _onGrabOpBegin(display, window, op) {
        if (!this._isSnappable(window)) return;
        const currentZone = this._findZoneForWindow(window);

        const [, , mods] = global.get_pointer();
        if ((mods & Clutter.ModifierType.CONTROL_MASK) !== 0) {
            window._tilingBypass = true;
            return;
        }
        delete window._tilingBypass;

        if (currentZone) {
            window.raise();
            window._tilingOriginalZone = currentZone;
        }
    }

    _onGrabOpEnd(display, window) {
        if (window._tilingBypass) {
            delete window._tilingBypass;
            this._highlighter.hideHoverHighlight();
            return;
        }

        if (!this._isSnappable(window)) return;

        this._highlighter.hideHoverHighlight();

        const [pointerX, pointerY] = global.get_pointer();
        const targetZone = this._findZoneAt(pointerX, pointerY);

        const originalZone = window._tilingOriginalZone;
        if (originalZone) {
            delete window._tilingOriginalZone;
        }

        if (originalZone && targetZone !== originalZone) {
            originalZone.unsnapWindow(window);
        }

        if (targetZone) {
            targetZone.snapWindow(window);
        }
    }

    _onWindowCreated(display, window) {
        GLib.timeout_add(GLib.PRIORITY_DEFAULT, 200, () => {
            if (!window || !this._isSnappable(window)) return GLib.SOURCE_REMOVE;

            const monitorIndex = window.get_monitor();
            const primaryZone = this._zones.find(z =>
                z.monitorIndex === monitorIndex && z.isPrimary
            );

            if (primaryZone) {
                log(`New window "${window.get_title()}" snapping to primary zone.`);
                primaryZone.snapWindow(window);
            }
            return GLib.SOURCE_REMOVE;
        });
    }

    _onTrackedWindowsChanged() {
        const trackedWindows = new Set(global.get_window_actors().map(a => a.get_meta_window()));

        for (const zone of this._zones) {
            const snappedWindows = zone.getSnappedWindows();
            for (const window of snappedWindows) {
                if (!trackedWindows.has(window)) {
                    log(`Window "${window.get_title()}" is no longer tracked, removing from zone "${zone.name}".`);
                    zone.unsnapWindow(window);
                }
            }
        }
    }

    _snapExistingWindows() {
        log("DEBUG: _snapExistingWindows() called.");
        const allWindows = global.get_window_actors().map(a => a.get_meta_window());
        allWindows.forEach(window => {
            if (this._isSnappable(window)) {
                let targetZone = this._findZoneForWindow(window);

                if (!targetZone) {
                    targetZone = this._findBestZoneForWindow(window);
                }

                if (targetZone) {
                    targetZone.snapWindow(window);
                }
            }
        });
        this._zones.forEach(zone => zone.reorderTabs());
        this._logZoneStates();
    }

    _logZoneStates() {
        log('--- Final Zone States ---');
        this._zones.forEach(zone => {
            const tabs = zone.getTabs();
            if (tabs.length === 0) return;

            log(`Zone "${zone.name}" contains ${tabs.length} tabs:`);
            tabs.forEach((tab, index) => {
                const appName = tab.app ? tab.app.get_name() : 'N/A';
                const windowTitle = tab.window.get_title() || 'N/A';
                const wmClass = tab.window.get_wm_class() || 'N/A';
                log(`  - [${index}] App='${appName}', Title='${windowTitle}', WMClass='${wmClass}'`);
            });
        });
    }

    _findBestZoneForWindow(window) {
        if (!window) return null;
        const frame = window.get_frame_rect();
        const centerX = frame.x + frame.width / 2;
        const centerY = frame.y + frame.height / 2;
        return this._findZoneAt(centerX, centerY);
    }

    _findZoneAt(x, y) {
        const monitorIndex = global.display.get_monitor_index_for_rect(
            new Mtk.Rectangle({ x, y, width: 1, height: 1 })
        );
        const monitor = Main.layoutManager.monitors[monitorIndex];
        if (!monitor) return null;

        for (const zone of this._zones) {
            if (zone.monitorIndex !== monitorIndex) continue;

            const zoneRect = {
                x: monitor.x + zone.x,
                y: monitor.y + zone.y,
                width: zone.width,
                height: zone.height,
            };

            if (x >= zoneRect.x && x <= zoneRect.x + zoneRect.width &&
                y >= zoneRect.y && y <= zoneRect.y + zoneRect.height) {
                return zone;
            }
        }
        return null;
    }

    _findZoneForWindow(window) {
        return this._zones.find(zone => zone.containsWindow(window));
    }
}



===== FILE: ./modules/Zone.js =====
// modules/Zone.js
import * as Main from 'resource:///org/gnome/shell/ui/main.js';
import Meta from 'gi://Meta';

import { TabBar } from './TabBar.js';

const log = msg => console.log(`[TabbedTiling.Zone] ${msg}`);

export class Zone {
    constructor(zoneData, tabBarConfig, windowTracker) {
        // Copy all properties from the config
        Object.assign(this, zoneData);

        this._snappedWindows = new Set();
        this._windowTracker = windowTracker;

        this._tabBar = new TabBar(tabBarConfig);
        this._tabBar.connect('tab-clicked', (actor, window) => this.activateWindow(window));
        // When the close button on a tab is clicked, the 'tab-removed' signal is emitted.
        // We connect this to an action that closes the actual window.
        this._tabBar.connect('tab-removed', (actor, window) => {
            window.delete(global.get_current_time());
        });
        this._tabBar.connect('tab-moved', (actor, { fromZone, toZone, window }) => {
            // This is a placeholder for inter-zone dragging logic
        });

        this._updateTabBarPosition();
        Main.layoutManager.addChrome(this._tabBar);
    }

    get monitor() {
        return Main.layoutManager.monitors[this.monitorIndex];
    }

    get rect() {
        if (!this.monitor) return null;
        return {
            x: this.monitor.x + this.x,
            y: this.monitor.y + this.y,
            width: this.width,
            height: this.height,
        };
    }

    _updateTabBarPosition() {
        if (!this.rect) return;
        const tabBarHeight = this._tabBar.height;
        this._tabBar.set_position(
            this.rect.x + this.gap,
            this.rect.y + this.gap
        );
        this._tabBar.set_size(this.rect.width - (2 * this.gap), tabBarHeight);
    }

    snapWindow(window) {
        if (!this.rect) return;

        if (window.get_maximized()) {
            window.unmaximize(Meta.MaximizeFlags.BOTH);
        }

        const tabBarHeight = this._tabBar.height;
        const newX = this.rect.x + this.gap;
        const newY = this.rect.y + this.gap + tabBarHeight; // Position window below tab bar
        const newWidth = this.rect.width - (2 * this.gap);
        const newHeight = this.rect.height - (2 * this.gap) - tabBarHeight;

        window.move_resize_frame(true, newX, newY, newWidth, newHeight);

        if (!this._snappedWindows.has(window)) {
            this._snappedWindows.add(window);
            window._tilingZoneId = this.name; // Tag the window
            this._tabBar.addTab(window);
        }

        this.activateWindow(window);
        this._updateVisibility();
    }

    unsnapWindow(window) {
        if (this._snappedWindows.has(window)) {
            this._snappedWindows.delete(window);
            delete window._tilingZoneId;
            this._tabBar.removeTab(window);

            // Activate the next tab if available
            if (this._snappedWindows.size > 0) {
                const nextWindow = this._snappedWindows.values().next().value;
                this.activateWindow(nextWindow);
            }
        }
        this._updateVisibility();
    }

    activateWindow(window) {
        if (this._snappedWindows.has(window)) {
            window.activate(global.get_current_time());
            this._tabBar.setActiveTab(window);
        }
    }

    containsWindow(window) {
        return this._snappedWindows.has(window);
    }

    _updateVisibility() {
        const shouldBeVisible = this._snappedWindows.size > 0;
        if (this._tabBar.visible !== shouldBeVisible) {
            this._tabBar.visible = shouldBeVisible;
        }
    }

    reorderTabs() {
        this._tabBar.reorderTabs(this.name);
    }

    getSnappedWindows() {
        // Return a copy to allow safe iteration while the original set might be modified.
        return new Set(this._snappedWindows);
    }

    getTabs() {
        return this._tabBar.getTabs();
    }

    destroy() {
        // Unsnap all windows before destroying
        [...this._snappedWindows].forEach(win => this.unsnapWindow(win));
        if (this._tabBar) {
            this._tabBar.destroy();
            this._tabBar = null;
        }
    }
}



===== FILE: ./metadata.json =====
{
"name": "Tabbed Tiling",
"description": "A tiling window manager for GNOME Shell that uses tabs to manage windows within predefined zones.",
"uuid": "tabbedtiling@george.com",
"version": 1,
"shell-version": ["48"],
"url": "https://github.com/george/tabbed-tiling",
"session-modes": ["user", "unlock-dialog"],
"settings-schema": "org.gnome.shell.extensions.tabbedtiling"
}


